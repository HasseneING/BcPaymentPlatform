{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */function () {\n  function SturdyWebSocket(url, protocolsOrOptions, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.url = url;\n    this.onclose = null;\n    this.onerror = null;\n    this.onmessage = null;\n    this.onopen = null;\n    this.ondown = null;\n    this.onreopen = null;\n    this.CONNECTING = SturdyWebSocket.CONNECTING;\n    this.OPEN = SturdyWebSocket.OPEN;\n    this.CLOSING = SturdyWebSocket.CLOSING;\n    this.CLOSED = SturdyWebSocket.CLOSED;\n    this.hasBeenOpened = false;\n    this.isClosed = false;\n    this.messageBuffer = [];\n    this.nextRetryTime = 0;\n    this.reconnectCount = 0;\n    this.lastKnownExtensions = \"\";\n    this.lastKnownProtocol = \"\";\n    this.listeners = {};\n    if (protocolsOrOptions == null || typeof protocolsOrOptions === \"string\" || Array.isArray(protocolsOrOptions)) {\n      this.protocols = protocolsOrOptions;\n    } else {\n      options = protocolsOrOptions;\n    }\n    this.options = applyDefaultOptions(options);\n    if (!this.options.wsConstructor) {\n      if (typeof WebSocket !== \"undefined\") {\n        this.options.wsConstructor = WebSocket;\n      } else {\n        throw new Error(\"WebSocket not present in global scope and no \" + \"wsConstructor option was provided.\");\n      }\n    }\n    this.openNewWebSocket();\n  }\n  Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n    get: function () {\n      return this.binaryTypeInternal || \"blob\";\n    },\n    set: function (binaryType) {\n      this.binaryTypeInternal = binaryType;\n      if (this.ws) {\n        this.ws.binaryType = binaryType;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n    get: function () {\n      var sum = this.ws ? this.ws.bufferedAmount : 0;\n      var hasUnknownAmount = false;\n      this.messageBuffer.forEach(function (data) {\n        var byteLength = getDataByteLength(data);\n        if (byteLength != null) {\n          sum += byteLength;\n        } else {\n          hasUnknownAmount = true;\n        }\n      });\n      if (hasUnknownAmount) {\n        this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" + \" return value may be below the correct amount.\");\n      }\n      return sum;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n    get: function () {\n      return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n    get: function () {\n      return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n    get: function () {\n      return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  SturdyWebSocket.prototype.close = function (code, reason) {\n    this.disposeSocket(code, reason);\n    this.shutdown();\n    this.debugLog(\"WebSocket permanently closed by client.\");\n  };\n  SturdyWebSocket.prototype.send = function (data) {\n    if (this.isClosed) {\n      throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n    } else if (this.ws && this.ws.readyState === this.OPEN) {\n      this.ws.send(data);\n    } else {\n      this.messageBuffer.push(data);\n    }\n  };\n  SturdyWebSocket.prototype.reconnect = function () {\n    if (this.isClosed) {\n      throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n    }\n    this.disposeSocket(1000, \"Client requested reconnect.\");\n    this.handleClose(undefined);\n  };\n  SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n    this.listeners[type].push(listener);\n  };\n  SturdyWebSocket.prototype.dispatchEvent = function (event) {\n    return this.dispatchEventOfType(event.type, event);\n  };\n  SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n    if (this.listeners[type]) {\n      this.listeners[type] = this.listeners[type].filter(function (l) {\n        return l !== listener;\n      });\n    }\n  };\n  SturdyWebSocket.prototype.openNewWebSocket = function () {\n    var _this = this;\n    if (this.isClosed) {\n      return;\n    }\n    var _a = this.options,\n      connectTimeout = _a.connectTimeout,\n      wsConstructor = _a.wsConstructor;\n    this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n    var ws = new wsConstructor(this.url, this.protocols);\n    ws.onclose = function (event) {\n      return _this.handleClose(event);\n    };\n    ws.onerror = function (event) {\n      return _this.handleError(event);\n    };\n    ws.onmessage = function (event) {\n      return _this.handleMessage(event);\n    };\n    ws.onopen = function (event) {\n      return _this.handleOpen(event);\n    };\n    this.connectTimeoutId = setTimeout(function () {\n      // If this is running, we still haven't opened the websocket.\n      // Kill it so we can try again.\n      _this.clearConnectTimeout();\n      _this.disposeSocket();\n      _this.handleClose(undefined);\n    }, connectTimeout);\n    this.ws = ws;\n  };\n  SturdyWebSocket.prototype.handleOpen = function (event) {\n    var _this = this;\n    if (!this.ws || this.isClosed) {\n      return;\n    }\n    var allClearResetTime = this.options.allClearResetTime;\n    this.debugLog(\"WebSocket opened.\");\n    if (this.binaryTypeInternal != null) {\n      this.ws.binaryType = this.binaryTypeInternal;\n    } else {\n      this.binaryTypeInternal = this.ws.binaryType;\n    }\n    this.clearConnectTimeout();\n    if (this.hasBeenOpened) {\n      this.dispatchEventOfType(\"reopen\", event);\n    } else {\n      this.dispatchEventOfType(\"open\", event);\n      this.hasBeenOpened = true;\n    }\n    this.messageBuffer.forEach(function (message) {\n      return _this.send(message);\n    });\n    this.messageBuffer = [];\n    this.allClearTimeoutId = setTimeout(function () {\n      _this.clearAllClearTimeout();\n      _this.nextRetryTime = 0;\n      _this.reconnectCount = 0;\n      var openTime = allClearResetTime / 1000 | 0;\n      _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" + \" retry time and count.\");\n    }, allClearResetTime);\n  };\n  SturdyWebSocket.prototype.handleMessage = function (event) {\n    if (this.isClosed) {\n      return;\n    }\n    this.dispatchEventOfType(\"message\", event);\n  };\n  SturdyWebSocket.prototype.handleClose = function (event) {\n    var _this = this;\n    if (this.isClosed) {\n      return;\n    }\n    var _a = this.options,\n      maxReconnectAttempts = _a.maxReconnectAttempts,\n      shouldReconnect = _a.shouldReconnect;\n    this.clearConnectTimeout();\n    this.clearAllClearTimeout();\n    if (this.ws) {\n      this.lastKnownExtensions = this.ws.extensions;\n      this.lastKnownProtocol = this.ws.protocol;\n      this.disposeSocket();\n    }\n    this.dispatchEventOfType(\"down\", event);\n    if (this.reconnectCount >= maxReconnectAttempts) {\n      this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n      return;\n    }\n    var willReconnect = !event || shouldReconnect(event);\n    if (typeof willReconnect === \"boolean\") {\n      this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n    } else {\n      willReconnect.then(function (willReconnectResolved) {\n        if (_this.isClosed) {\n          return;\n        }\n        _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n      });\n    }\n  };\n  SturdyWebSocket.prototype.handleError = function (event) {\n    this.dispatchEventOfType(\"error\", event);\n    this.debugLog(\"WebSocket encountered an error.\");\n  };\n  SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n    if (willReconnect) {\n      this.reestablishConnection();\n    } else {\n      this.stopReconnecting(event, denialReason);\n    }\n  };\n  SturdyWebSocket.prototype.reestablishConnection = function () {\n    var _this = this;\n    var _a = this.options,\n      minReconnectDelay = _a.minReconnectDelay,\n      maxReconnectDelay = _a.maxReconnectDelay,\n      reconnectBackoffFactor = _a.reconnectBackoffFactor;\n    this.reconnectCount++;\n    var retryTime = this.nextRetryTime;\n    this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n    setTimeout(function () {\n      return _this.openNewWebSocket();\n    }, retryTime);\n    var retryTimeSeconds = retryTime / 1000 | 0;\n    this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n  };\n  SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n    this.debugLog(debugReason);\n    this.shutdown();\n    if (event) {\n      this.dispatchEventOfType(\"close\", event);\n    }\n  };\n  SturdyWebSocket.prototype.shutdown = function () {\n    this.isClosed = true;\n    this.clearAllTimeouts();\n    this.messageBuffer = [];\n    this.disposeSocket();\n  };\n  SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n    if (!this.ws) {\n      return;\n    }\n    // Use noop handlers instead of null because some WebSocket\n    // implementations, such as the one from isomorphic-ws, raise a stink on\n    // unhandled events.\n    this.ws.onerror = noop;\n    this.ws.onclose = noop;\n    this.ws.onmessage = noop;\n    this.ws.onopen = noop;\n    this.ws.close(closeCode, reason);\n    this.ws = undefined;\n  };\n  SturdyWebSocket.prototype.clearAllTimeouts = function () {\n    this.clearConnectTimeout();\n    this.clearAllClearTimeout();\n  };\n  SturdyWebSocket.prototype.clearConnectTimeout = function () {\n    if (this.connectTimeoutId != null) {\n      clearTimeout(this.connectTimeoutId);\n      this.connectTimeoutId = undefined;\n    }\n  };\n  SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n    if (this.allClearTimeoutId != null) {\n      clearTimeout(this.allClearTimeoutId);\n      this.allClearTimeoutId = undefined;\n    }\n  };\n  SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n    var _this = this;\n    switch (type) {\n      case \"close\":\n        if (this.onclose) {\n          this.onclose(event);\n        }\n        break;\n      case \"error\":\n        if (this.onerror) {\n          this.onerror(event);\n        }\n        break;\n      case \"message\":\n        if (this.onmessage) {\n          this.onmessage(event);\n        }\n        break;\n      case \"open\":\n        if (this.onopen) {\n          this.onopen(event);\n        }\n        break;\n      case \"down\":\n        if (this.ondown) {\n          this.ondown(event);\n        }\n        break;\n      case \"reopen\":\n        if (this.onreopen) {\n          this.onreopen(event);\n        }\n        break;\n    }\n    if (type in this.listeners) {\n      this.listeners[type].slice().forEach(function (listener) {\n        return _this.callListener(listener, event);\n      });\n    }\n    return !event || !event.defaultPrevented;\n  };\n  SturdyWebSocket.prototype.callListener = function (listener, event) {\n    if (typeof listener === \"function\") {\n      listener.call(this, event);\n    } else {\n      listener.handleEvent.call(this, event);\n    }\n  };\n  SturdyWebSocket.prototype.debugLog = function (message) {\n    if (this.options.debug) {\n      // tslint:disable-next-line:no-console\n      console.log(message);\n    }\n  };\n  SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n    var maxReconnectAttempts = this.options.maxReconnectAttempts;\n    return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n  };\n  SturdyWebSocket.DEFAULT_OPTIONS = {\n    allClearResetTime: 5000,\n    connectTimeout: 5000,\n    debug: false,\n    minReconnectDelay: 1000,\n    maxReconnectDelay: 30000,\n    maxReconnectAttempts: Number.POSITIVE_INFINITY,\n    reconnectBackoffFactor: 1.5,\n    shouldReconnect: function () {\n      return true;\n    },\n    wsConstructor: undefined\n  };\n  SturdyWebSocket.CONNECTING = 0;\n  SturdyWebSocket.OPEN = 1;\n  SturdyWebSocket.CLOSING = 2;\n  SturdyWebSocket.CLOSED = 3;\n  return SturdyWebSocket;\n}();\nexports.default = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n  var result = {};\n  Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n    var value = options[key];\n    result[key] = value === undefined ? SturdyWebSocket.DEFAULT_OPTIONS[key] : value;\n  });\n  return result;\n}\nfunction getDataByteLength(data) {\n  if (typeof data === \"string\") {\n    // UTF-16 strings use two bytes per character.\n    return 2 * data.length;\n  } else if (data instanceof ArrayBuffer) {\n    return data.byteLength;\n  } else if (data instanceof Blob) {\n    return data.size;\n  } else {\n    return undefined;\n  }\n}\nfunction pluralize(s, n) {\n  return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n  // Nothing.\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","SHOULD_RECONNECT_FALSE_MESSAGE","SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE","SturdyWebSocket","url","protocolsOrOptions","options","onclose","onerror","onmessage","onopen","ondown","onreopen","CONNECTING","OPEN","CLOSING","CLOSED","hasBeenOpened","isClosed","messageBuffer","nextRetryTime","reconnectCount","lastKnownExtensions","lastKnownProtocol","listeners","Array","isArray","protocols","applyDefaultOptions","wsConstructor","WebSocket","Error","openNewWebSocket","prototype","get","binaryTypeInternal","set","binaryType","ws","enumerable","configurable","sum","bufferedAmount","hasUnknownAmount","forEach","data","byteLength","getDataByteLength","debugLog","extensions","protocol","close","code","reason","disposeSocket","shutdown","send","readyState","push","reconnect","handleClose","undefined","addEventListener","type","listener","dispatchEvent","event","dispatchEventOfType","removeEventListener","filter","l","_this","_a","connectTimeout","handleError","handleMessage","handleOpen","connectTimeoutId","setTimeout","clearConnectTimeout","allClearResetTime","message","allClearTimeoutId","clearAllClearTimeout","openTime","maxReconnectAttempts","shouldReconnect","stopReconnecting","getTooManyFailedReconnectsMessage","willReconnect","handleWillReconnect","then","willReconnectResolved","denialReason","reestablishConnection","minReconnectDelay","maxReconnectDelay","reconnectBackoffFactor","retryTime","Math","max","min","retryTimeSeconds","debugReason","clearAllTimeouts","closeCode","noop","clearTimeout","slice","callListener","defaultPrevented","call","handleEvent","debug","console","log","pluralize","DEFAULT_OPTIONS","Number","POSITIVE_INFINITY","default","result","keys","key","length","ArrayBuffer","Blob","size","s","n"],"sources":["F:/DDesktop/MEAN_BC/mean-stack-authentication-authorization-master/angular-15-client/node_modules/sturdy-websocket/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        if (options === void 0) { options = {}; }\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        }\n        else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        if (this.isClosed) {\n            throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            _this.disposeSocket();\n            _this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reestablishConnection();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reestablishConnection = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    };\n    SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports.default = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n    var result = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n        var value = options[key];\n        result[key] =\n            value === undefined\n                ? SturdyWebSocket.DEFAULT_OPTIONS[key]\n                : value;\n    });\n    return result;\n}\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n    // Nothing.\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}