{"ast":null,"code":"\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\nimport _BN from \"bn.js\";\nvar BN = _BN.BN;\nimport { hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst _constructorGuard = {};\nconst MAX_SAFE = 0x1fffffffffffff;\nexport function isBigNumberish(value) {\n  return value != null && (BigNumber.isBigNumber(value) || typeof value === \"number\" && value % 1 === 0 || typeof value === \"string\" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === \"bigint\" || isBytes(value));\n}\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\nexport class BigNumber {\n  constructor(constructorGuard, hex) {\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new (BigNumber)\"\n      });\n    }\n    this._hex = hex;\n    this._isBigNumber = true;\n    Object.freeze(this);\n  }\n  fromTwos(value) {\n    return toBigNumber(toBN(this).fromTwos(value));\n  }\n  toTwos(value) {\n    return toBigNumber(toBN(this).toTwos(value));\n  }\n  abs() {\n    if (this._hex[0] === \"-\") {\n      return BigNumber.from(this._hex.substring(1));\n    }\n    return this;\n  }\n  add(other) {\n    return toBigNumber(toBN(this).add(toBN(other)));\n  }\n  sub(other) {\n    return toBigNumber(toBN(this).sub(toBN(other)));\n  }\n  div(other) {\n    const o = BigNumber.from(other);\n    if (o.isZero()) {\n      throwFault(\"division-by-zero\", \"div\");\n    }\n    return toBigNumber(toBN(this).div(toBN(other)));\n  }\n  mul(other) {\n    return toBigNumber(toBN(this).mul(toBN(other)));\n  }\n  mod(other) {\n    const value = toBN(other);\n    if (value.isNeg()) {\n      throwFault(\"division-by-zero\", \"mod\");\n    }\n    return toBigNumber(toBN(this).umod(value));\n  }\n  pow(other) {\n    const value = toBN(other);\n    if (value.isNeg()) {\n      throwFault(\"negative-power\", \"pow\");\n    }\n    return toBigNumber(toBN(this).pow(value));\n  }\n  and(other) {\n    const value = toBN(other);\n    if (this.isNegative() || value.isNeg()) {\n      throwFault(\"unbound-bitwise-result\", \"and\");\n    }\n    return toBigNumber(toBN(this).and(value));\n  }\n  or(other) {\n    const value = toBN(other);\n    if (this.isNegative() || value.isNeg()) {\n      throwFault(\"unbound-bitwise-result\", \"or\");\n    }\n    return toBigNumber(toBN(this).or(value));\n  }\n  xor(other) {\n    const value = toBN(other);\n    if (this.isNegative() || value.isNeg()) {\n      throwFault(\"unbound-bitwise-result\", \"xor\");\n    }\n    return toBigNumber(toBN(this).xor(value));\n  }\n  mask(value) {\n    if (this.isNegative() || value < 0) {\n      throwFault(\"negative-width\", \"mask\");\n    }\n    return toBigNumber(toBN(this).maskn(value));\n  }\n  shl(value) {\n    if (this.isNegative() || value < 0) {\n      throwFault(\"negative-width\", \"shl\");\n    }\n    return toBigNumber(toBN(this).shln(value));\n  }\n  shr(value) {\n    if (this.isNegative() || value < 0) {\n      throwFault(\"negative-width\", \"shr\");\n    }\n    return toBigNumber(toBN(this).shrn(value));\n  }\n  eq(other) {\n    return toBN(this).eq(toBN(other));\n  }\n  lt(other) {\n    return toBN(this).lt(toBN(other));\n  }\n  lte(other) {\n    return toBN(this).lte(toBN(other));\n  }\n  gt(other) {\n    return toBN(this).gt(toBN(other));\n  }\n  gte(other) {\n    return toBN(this).gte(toBN(other));\n  }\n  isNegative() {\n    return this._hex[0] === \"-\";\n  }\n  isZero() {\n    return toBN(this).isZero();\n  }\n  toNumber() {\n    try {\n      return toBN(this).toNumber();\n    } catch (error) {\n      throwFault(\"overflow\", \"toNumber\", this.toString());\n    }\n    return null;\n  }\n  toBigInt() {\n    try {\n      return BigInt(this.toString());\n    } catch (e) {}\n    return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n      value: this.toString()\n    });\n  }\n  toString() {\n    // Lots of people expect this, which we do not support, so check (See: #889)\n    if (arguments.length > 0) {\n      if (arguments[0] === 10) {\n        if (!_warnedToStringRadix) {\n          _warnedToStringRadix = true;\n          logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n        }\n      } else if (arguments[0] === 16) {\n        logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n      } else {\n        logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n      }\n    }\n    return toBN(this).toString(10);\n  }\n  toHexString() {\n    return this._hex;\n  }\n  toJSON(key) {\n    return {\n      type: \"BigNumber\",\n      hex: this.toHexString()\n    };\n  }\n  static from(value) {\n    if (value instanceof BigNumber) {\n      return value;\n    }\n    if (typeof value === \"string\") {\n      if (value.match(/^-?0x[0-9a-f]+$/i)) {\n        return new BigNumber(_constructorGuard, toHex(value));\n      }\n      if (value.match(/^-?[0-9]+$/)) {\n        return new BigNumber(_constructorGuard, toHex(new BN(value)));\n      }\n      return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n    }\n    if (typeof value === \"number\") {\n      if (value % 1) {\n        throwFault(\"underflow\", \"BigNumber.from\", value);\n      }\n      if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n        throwFault(\"overflow\", \"BigNumber.from\", value);\n      }\n      return BigNumber.from(String(value));\n    }\n    const anyValue = value;\n    if (typeof anyValue === \"bigint\") {\n      return BigNumber.from(anyValue.toString());\n    }\n    if (isBytes(anyValue)) {\n      return BigNumber.from(hexlify(anyValue));\n    }\n    if (anyValue) {\n      // Hexable interface (takes priority)\n      if (anyValue.toHexString) {\n        const hex = anyValue.toHexString();\n        if (typeof hex === \"string\") {\n          return BigNumber.from(hex);\n        }\n      } else {\n        // For now, handle legacy JSON-ified values (goes away in v6)\n        let hex = anyValue._hex;\n        // New-form JSON\n        if (hex == null && anyValue.type === \"BigNumber\") {\n          hex = anyValue.hex;\n        }\n        if (typeof hex === \"string\") {\n          if (isHexString(hex) || hex[0] === \"-\" && isHexString(hex.substring(1))) {\n            return BigNumber.from(hex);\n          }\n        }\n      }\n    }\n    return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n  }\n  static isBigNumber(value) {\n    return !!(value && value._isBigNumber);\n  }\n}\n// Normalize the hex string\nfunction toHex(value) {\n  // For BN, call on the hex string\n  if (typeof value !== \"string\") {\n    return toHex(value.toString(16));\n  }\n  // If negative, prepend the negative sign to the normalized positive value\n  if (value[0] === \"-\") {\n    // Strip off the negative sign\n    value = value.substring(1);\n    // Cannot have multiple negative signs (e.g. \"--0x04\")\n    if (value[0] === \"-\") {\n      logger.throwArgumentError(\"invalid hex\", \"value\", value);\n    }\n    // Call toHex on the positive component\n    value = toHex(value);\n    // Do not allow \"-0x00\"\n    if (value === \"0x00\") {\n      return value;\n    }\n    // Negate the value\n    return \"-\" + value;\n  }\n  // Add a \"0x\" prefix if missing\n  if (value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  }\n  // Normalize zero\n  if (value === \"0x\") {\n    return \"0x00\";\n  }\n  // Make the string even length\n  if (value.length % 2) {\n    value = \"0x0\" + value.substring(2);\n  }\n  // Trim to smallest even-length string\n  while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n    value = \"0x\" + value.substring(4);\n  }\n  return value;\n}\nfunction toBigNumber(value) {\n  return BigNumber.from(toHex(value));\n}\nfunction toBN(value) {\n  const hex = BigNumber.from(value).toHexString();\n  if (hex[0] === \"-\") {\n    return new BN(\"-\" + hex.substring(3), 16);\n  }\n  return new BN(hex.substring(2), 16);\n}\nfunction throwFault(fault, operation, value) {\n  const params = {\n    fault: fault,\n    operation: operation\n  };\n  if (value != null) {\n    params.value = value;\n  }\n  return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n// value should have no prefix\nexport function _base36To16(value) {\n  return new BN(value, 36).toString(16);\n}\n// value should have no prefix\nexport function _base16To36(value) {\n  return new BN(value, 16).toString(36);\n}","map":{"version":3,"names":["_BN","BN","hexlify","isBytes","isHexString","Logger","version","logger","_constructorGuard","MAX_SAFE","isBigNumberish","value","BigNumber","isBigNumber","match","_warnedToStringRadix","constructor","constructorGuard","hex","throwError","errors","UNSUPPORTED_OPERATION","operation","_hex","_isBigNumber","Object","freeze","fromTwos","toBigNumber","toBN","toTwos","abs","from","substring","add","other","sub","div","o","isZero","throwFault","mul","mod","isNeg","umod","pow","and","isNegative","or","xor","mask","maskn","shl","shln","shr","shrn","eq","lt","lte","gt","gte","toNumber","error","toString","toBigInt","BigInt","e","arguments","length","warn","UNEXPECTED_ARGUMENT","toHexString","toJSON","key","type","toHex","throwArgumentError","String","anyValue","fault","params","NUMERIC_FAULT","_base36To16","_base16To36"],"sources":["F:/DDesktop/MEAN_BC/mean-stack-authentication-authorization-master/angular-15-client/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js"],"sourcesContent":["\"use strict\";\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\nimport _BN from \"bn.js\";\nvar BN = _BN.BN;\nimport { hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst _constructorGuard = {};\nconst MAX_SAFE = 0x1fffffffffffff;\nexport function isBigNumberish(value) {\n    return (value != null) && (BigNumber.isBigNumber(value) ||\n        (typeof (value) === \"number\" && (value % 1) === 0) ||\n        (typeof (value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof (value) === \"bigint\") ||\n        isBytes(value));\n}\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\nexport class BigNumber {\n    constructor(constructorGuard, hex) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n        this._hex = hex;\n        this._isBigNumber = true;\n        Object.freeze(this);\n    }\n    fromTwos(value) {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n    toTwos(value) {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n    abs() {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n    add(other) {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n    sub(other) {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n    div(other) {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n    mul(other) {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n    mod(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n    pow(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n    and(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n    or(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n    xor(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n    mask(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n    shl(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n    shr(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n    eq(other) {\n        return toBN(this).eq(toBN(other));\n    }\n    lt(other) {\n        return toBN(this).lt(toBN(other));\n    }\n    lte(other) {\n        return toBN(this).lte(toBN(other));\n    }\n    gt(other) {\n        return toBN(this).gt(toBN(other));\n    }\n    gte(other) {\n        return toBN(this).gte(toBN(other));\n    }\n    isNegative() {\n        return (this._hex[0] === \"-\");\n    }\n    isZero() {\n        return toBN(this).isZero();\n    }\n    toNumber() {\n        try {\n            return toBN(this).toNumber();\n        }\n        catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n    toBigInt() {\n        try {\n            return BigInt(this.toString());\n        }\n        catch (e) { }\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n    toString() {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            }\n            else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n            else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n        }\n        return toBN(this).toString(10);\n    }\n    toHexString() {\n        return this._hex;\n    }\n    toJSON(key) {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n    static from(value) {\n        if (value instanceof BigNumber) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n        if (typeof (value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n            return BigNumber.from(String(value));\n        }\n        const anyValue = value;\n        if (typeof (anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n        if (anyValue) {\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof (hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n            }\n            else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n                if (typeof (hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n    static isBigNumber(value) {\n        return !!(value && value._isBigNumber);\n    }\n}\n// Normalize the hex string\nfunction toHex(value) {\n    // For BN, call on the hex string\n    if (typeof (value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") {\n            logger.throwArgumentError(\"invalid hex\", \"value\", value);\n        }\n        // Call toHex on the positive component\n        value = toHex(value);\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") {\n            return value;\n        }\n        // Negate the value\n        return \"-\" + value;\n    }\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    // Normalize zero\n    if (value === \"0x\") {\n        return \"0x00\";\n    }\n    // Make the string even length\n    if (value.length % 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n    return value;\n}\nfunction toBigNumber(value) {\n    return BigNumber.from(toHex(value));\n}\nfunction toBN(value) {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\nfunction throwFault(fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value != null) {\n        params.value = value;\n    }\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n// value should have no prefix\nexport function _base36To16(value) {\n    return (new BN(value, 36)).toString(16);\n}\n// value should have no prefix\nexport function _base16To36(value) {\n    return (new BN(value, 16)).toString(36);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}