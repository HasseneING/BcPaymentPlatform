{"ast":null,"code":"import { _ as __awaiter, D as DEFAULT_ALCHEMY_API_KEY, C as CustomNetworks, a as DEFAULT_NETWORK, N as Network, I as IS_BROWSER, V as VERSION, l as logWarn, d as deepCopy, E as EthersNetwork, g as getAlchemyHttpUrl, b as getAlchemyWsUrl } from './index-596122b1.js';\nimport { getNetwork } from '@ethersproject/networks';\nimport { JsonRpcProvider } from '@ethersproject/providers';\nimport { fetchJson } from '@ethersproject/web';\nimport './api/utils';\nimport '@ethersproject/bignumber';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\n\n/** Maximum size of a batch on the rpc provider. */\nconst DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\n/** Timeout interval before the pending batch is sent. */\nconst DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\n/**\r\n * Internal class to enqueue requests and automatically send/process batches.\r\n *\r\n * The underlying batching mechanism is loosely based on ethers.js's\r\n * `JsonRpcBatchProvider`.\r\n *\r\n * @internal\r\n */\nclass RequestBatcher {\n  constructor(sendBatchFn, maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE) {\n    this.sendBatchFn = sendBatchFn;\n    this.maxBatchSize = maxBatchSize;\n    /**\r\n     * Array of enqueued requests along with the constructed promise handlers for\r\n     * each request.\r\n     */\n    this.pendingBatch = [];\n  }\n  /**\r\n   * Enqueues the provided request. The batch is immediately sent if the maximum\r\n   * batch size is reached. Otherwise, the request is enqueued onto a batch that\r\n   * is sent after 10ms.\r\n   *\r\n   * Returns a promise that resolves with the result of the request.\r\n   */\n  enqueueRequest(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const inflightRequest = {\n        request,\n        resolve: undefined,\n        reject: undefined\n      };\n      const promise = new Promise((resolve, reject) => {\n        inflightRequest.resolve = resolve;\n        inflightRequest.reject = reject;\n      });\n      this.pendingBatch.push(inflightRequest);\n      if (this.pendingBatch.length === this.maxBatchSize) {\n        // Send batch immediately if we are at the maximum batch size.\n        void this.sendBatchRequest();\n      } else if (!this.pendingBatchTimer) {\n        // Schedule batch for next event loop + short duration\n        this.pendingBatchTimer = setTimeout(() => this.sendBatchRequest(), DEFAULT_REQUEST_BATCH_DELAY_MS);\n      }\n      return promise;\n    });\n  }\n  /**\r\n   * Sends the currently queued batches and resets the batch and timer. Processes\r\n   * the batched response results back to the original promises.\r\n   */\n  sendBatchRequest() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Get the current batch and clear it, so new requests\n      // go into the next batch\n      const batch = this.pendingBatch;\n      this.pendingBatch = [];\n      if (this.pendingBatchTimer) {\n        clearTimeout(this.pendingBatchTimer);\n        this.pendingBatchTimer = undefined;\n      }\n      // Get the request as an array of requests\n      const request = batch.map(inflight => inflight.request);\n      return this.sendBatchFn(request).then(result => {\n        // For each result, feed it to the correct Promise, depending\n        // on whether it was a success or error\n        batch.forEach((inflightRequest, index) => {\n          const payload = result[index];\n          if (payload.error) {\n            const error = new Error(payload.error.message);\n            error.code = payload.error.code;\n            error.data = payload.error.data;\n            inflightRequest.reject(error);\n          } else {\n            inflightRequest.resolve(payload.result);\n          }\n        });\n      }, error => {\n        batch.forEach(inflightRequest => {\n          inflightRequest.reject(error);\n        });\n      });\n    });\n  }\n}\n\n/**\r\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\r\n *\r\n * @public\r\n */\nclass AlchemyProvider extends JsonRpcProvider {\n  /** @internal */\n  constructor(config) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'http');\n    // If a hardcoded url was specified in the config, use that instead of the\n    // provided apiKey or network.\n    if (config.url !== undefined) {\n      connection.url = config.url;\n    }\n    connection.throttleLimit = config.maxRetries;\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(connection, ethersNetwork);\n    this.apiKey = config.apiKey;\n    this.maxRetries = config.maxRetries;\n    this.batchRequests = config.batchRequests;\n    // TODO: support individual headers when calling batch\n    const batcherConnection = Object.assign(Object.assign({}, this.connection), {\n      headers: Object.assign(Object.assign({}, this.connection.headers), {\n        'Alchemy-Ethers-Sdk-Method': 'batchSend'\n      })\n    });\n    const sendBatchFn = requests => {\n      return fetchJson(batcherConnection, JSON.stringify(requests));\n    };\n    this.batcher = new RequestBatcher(sendBatchFn);\n  }\n  /**\r\n   * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\r\n   * ethers.js. Returns the API key for an Alchemy provider.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  static getApiKey(apiKey) {\n    if (apiKey == null) {\n      return DEFAULT_ALCHEMY_API_KEY;\n    }\n    if (apiKey && typeof apiKey !== 'string') {\n      throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);\n    }\n    return apiKey;\n  }\n  /**\r\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n   *\r\n   * This override allows the SDK to set the provider's network to values not\r\n   * yet supported by ethers.js.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  static getNetwork(network) {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetwork(network);\n  }\n  /**\r\n   * Converts the `Networkish` input to the network enum used by Alchemy.\r\n   *\r\n   * @internal\r\n   */\n  static getAlchemyNetwork(network) {\n    if (network === undefined) {\n      return DEFAULT_NETWORK;\n    }\n    if (typeof network === 'number') {\n      throw new Error(`Invalid network '${network}' provided. Network must be a string.`);\n    }\n    // Guaranteed that `typeof network === 'string`.\n    const isValidNetwork = Object.values(Network).includes(network);\n    if (!isValidNetwork) {\n      throw new Error(`Invalid network '${network}' provided. Network must be one of: ` + `${Object.values(Network).join(', ')}.`);\n    }\n    return network;\n  }\n  /**\r\n   * Returns a {@link ConnectionInfo} object compatible with ethers that contains\r\n   * the correct URLs for Alchemy.\r\n   *\r\n   * @internal\r\n   */\n  static getAlchemyConnectionInfo(network, apiKey, type) {\n    const url = type === 'http' ? getAlchemyHttpUrl(network, apiKey) : getAlchemyWsUrl(network, apiKey);\n    return {\n      headers: IS_BROWSER ? {\n        'Alchemy-Ethers-Sdk-Version': VERSION\n      } : {\n        'Alchemy-Ethers-Sdk-Version': VERSION,\n        'Accept-Encoding': 'gzip'\n      },\n      allowGzip: true,\n      url\n    };\n  }\n  /**\r\n   * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\r\n   * method is called when calling methods on the parent class `BaseProvider`.\r\n   *\r\n   * @override\r\n   */\n  detectNetwork() {\n    const _super = Object.create(null, {\n      detectNetwork: {\n        get: () => super.detectNetwork\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      let network = this.network;\n      if (network == null) {\n        network = yield _super.detectNetwork.call(this);\n        if (!network) {\n          throw new Error('No network detected');\n        }\n      }\n      return network;\n    });\n  }\n  _startPending() {\n    logWarn('WARNING: Alchemy Provider does not support pending filters');\n  }\n  /**\r\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n   * current api key is the default key.\r\n   *\r\n   * @override\r\n   */\n  isCommunityResource() {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n  /**\r\n   * Overrides the base {@link JsonRpcProvider.send} method to implement custom\r\n   * logic for sending requests to Alchemy.\r\n   *\r\n   * @param method The method name to use for the request.\r\n   * @param params The parameters to use for the request.\r\n   * @override\r\n   * @public\r\n   */\n  // TODO: Add headers for `perform()` override.\n  send(method, params) {\n    return this._send(method, params, 'send');\n  }\n  /**\r\n   * DO NOT MODIFY.\r\n   *\r\n   * Original code copied over from ether.js's `JsonRpcProvider.send()`.\r\n   *\r\n   * This method is copied over directly in order to implement custom headers\r\n   *\r\n   * @internal\r\n   */\n  _send(method, params, methodName, forceBatch = false) {\n    const request = {\n      method,\n      params,\n      id: this._nextId++,\n      jsonrpc: '2.0'\n    };\n    // START MODIFIED CODE\n    const connection = Object.assign({}, this.connection);\n    connection.headers['Alchemy-Ethers-Sdk-Method'] = methodName;\n    if (this.batchRequests || forceBatch) {\n      return this.batcher.enqueueRequest(request);\n    }\n    // END MODIFIED CODE\n    this.emit('debug', {\n      action: 'request',\n      request: deepCopy(request),\n      provider: this\n    });\n    // We can expand this in the future to any call, but for now these\n    // are the biggest wins and do not require any serializing parameters.\n    const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\n    if (cache && this._cache[method]) {\n      return this._cache[method];\n    }\n    const result = fetchJson(this.connection, JSON.stringify(request), getResult).then(result => {\n      this.emit('debug', {\n        action: 'response',\n        request,\n        response: result,\n        provider: this\n      });\n      return result;\n    }, error => {\n      this.emit('debug', {\n        action: 'response',\n        error,\n        request,\n        provider: this\n      });\n      throw error;\n    });\n    // Cache the fetch, but clear it on the next event loop\n    if (cache) {\n      this._cache[method] = result;\n      setTimeout(() => {\n        // @ts-ignore - This is done by ethers.\n        this._cache[method] = null;\n      }, 0);\n    }\n    return result;\n  }\n}\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Original code copied over from ether.js's\r\n * `@ethersproject/web/src.ts/index.ts`. Used to support\r\n * {@link AlchemyProvider._send}, which is also copied over.\r\n */\nfunction getResult(payload) {\n  if (payload.error) {\n    const error = new Error(payload.error.message);\n    error.code = payload.error.code;\n    error.data = payload.error.data;\n    throw error;\n  }\n  return payload.result;\n}\nexport { AlchemyProvider };","map":{"version":3,"names":["_","__awaiter","D","DEFAULT_ALCHEMY_API_KEY","C","CustomNetworks","a","DEFAULT_NETWORK","N","Network","I","IS_BROWSER","V","VERSION","l","logWarn","d","deepCopy","E","EthersNetwork","g","getAlchemyHttpUrl","b","getAlchemyWsUrl","getNetwork","JsonRpcProvider","fetchJson","DEFAULT_MAX_REQUEST_BATCH_SIZE","DEFAULT_REQUEST_BATCH_DELAY_MS","RequestBatcher","constructor","sendBatchFn","maxBatchSize","pendingBatch","enqueueRequest","request","inflightRequest","resolve","undefined","reject","promise","Promise","push","length","sendBatchRequest","pendingBatchTimer","setTimeout","batch","clearTimeout","map","inflight","then","result","forEach","index","payload","error","Error","message","code","data","AlchemyProvider","config","apiKey","getApiKey","alchemyNetwork","getAlchemyNetwork","network","connection","getAlchemyConnectionInfo","url","throttleLimit","maxRetries","ethersNetwork","batchRequests","batcherConnection","Object","assign","headers","requests","JSON","stringify","batcher","isValidNetwork","values","includes","join","type","allowGzip","detectNetwork","_super","create","get","call","_startPending","isCommunityResource","send","method","params","_send","methodName","forceBatch","id","_nextId","jsonrpc","emit","action","provider","cache","indexOf","_cache","getResult","response"],"sources":["F:/DDesktop/MEAN_BC/mean-stack-authentication-authorization-master/angular-15-client/node_modules/alchemy-sdk/dist/esm/alchemy-provider-afa3762a.js"],"sourcesContent":["import { _ as __awaiter, D as DEFAULT_ALCHEMY_API_KEY, C as CustomNetworks, a as DEFAULT_NETWORK, N as Network, I as IS_BROWSER, V as VERSION, l as logWarn, d as deepCopy, E as EthersNetwork, g as getAlchemyHttpUrl, b as getAlchemyWsUrl } from './index-596122b1.js';\nimport { getNetwork } from '@ethersproject/networks';\nimport { JsonRpcProvider } from '@ethersproject/providers';\nimport { fetchJson } from '@ethersproject/web';\nimport './api/utils';\nimport '@ethersproject/bignumber';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\n\n/** Maximum size of a batch on the rpc provider. */\r\nconst DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\r\n/** Timeout interval before the pending batch is sent. */\r\nconst DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\r\n/**\r\n * Internal class to enqueue requests and automatically send/process batches.\r\n *\r\n * The underlying batching mechanism is loosely based on ethers.js's\r\n * `JsonRpcBatchProvider`.\r\n *\r\n * @internal\r\n */\r\nclass RequestBatcher {\r\n    constructor(sendBatchFn, maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE) {\r\n        this.sendBatchFn = sendBatchFn;\r\n        this.maxBatchSize = maxBatchSize;\r\n        /**\r\n         * Array of enqueued requests along with the constructed promise handlers for\r\n         * each request.\r\n         */\r\n        this.pendingBatch = [];\r\n    }\r\n    /**\r\n     * Enqueues the provided request. The batch is immediately sent if the maximum\r\n     * batch size is reached. Otherwise, the request is enqueued onto a batch that\r\n     * is sent after 10ms.\r\n     *\r\n     * Returns a promise that resolves with the result of the request.\r\n     */\r\n    enqueueRequest(request) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const inflightRequest = {\r\n                request,\r\n                resolve: undefined,\r\n                reject: undefined\r\n            };\r\n            const promise = new Promise((resolve, reject) => {\r\n                inflightRequest.resolve = resolve;\r\n                inflightRequest.reject = reject;\r\n            });\r\n            this.pendingBatch.push(inflightRequest);\r\n            if (this.pendingBatch.length === this.maxBatchSize) {\r\n                // Send batch immediately if we are at the maximum batch size.\r\n                void this.sendBatchRequest();\r\n            }\r\n            else if (!this.pendingBatchTimer) {\r\n                // Schedule batch for next event loop + short duration\r\n                this.pendingBatchTimer = setTimeout(() => this.sendBatchRequest(), DEFAULT_REQUEST_BATCH_DELAY_MS);\r\n            }\r\n            return promise;\r\n        });\r\n    }\r\n    /**\r\n     * Sends the currently queued batches and resets the batch and timer. Processes\r\n     * the batched response results back to the original promises.\r\n     */\r\n    sendBatchRequest() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Get the current batch and clear it, so new requests\r\n            // go into the next batch\r\n            const batch = this.pendingBatch;\r\n            this.pendingBatch = [];\r\n            if (this.pendingBatchTimer) {\r\n                clearTimeout(this.pendingBatchTimer);\r\n                this.pendingBatchTimer = undefined;\r\n            }\r\n            // Get the request as an array of requests\r\n            const request = batch.map(inflight => inflight.request);\r\n            return this.sendBatchFn(request).then(result => {\r\n                // For each result, feed it to the correct Promise, depending\r\n                // on whether it was a success or error\r\n                batch.forEach((inflightRequest, index) => {\r\n                    const payload = result[index];\r\n                    if (payload.error) {\r\n                        const error = new Error(payload.error.message);\r\n                        error.code = payload.error.code;\r\n                        error.data = payload.error.data;\r\n                        inflightRequest.reject(error);\r\n                    }\r\n                    else {\r\n                        inflightRequest.resolve(payload.result);\r\n                    }\r\n                });\r\n            }, error => {\r\n                batch.forEach(inflightRequest => {\r\n                    inflightRequest.reject(error);\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\n\n/**\r\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyProvider extends JsonRpcProvider {\r\n    /** @internal */\r\n    constructor(config) {\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'http');\r\n        // If a hardcoded url was specified in the config, use that instead of the\r\n        // provided apiKey or network.\r\n        if (config.url !== undefined) {\r\n            connection.url = config.url;\r\n        }\r\n        connection.throttleLimit = config.maxRetries;\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = EthersNetwork[alchemyNetwork];\r\n        super(connection, ethersNetwork);\r\n        this.apiKey = config.apiKey;\r\n        this.maxRetries = config.maxRetries;\r\n        this.batchRequests = config.batchRequests;\r\n        // TODO: support individual headers when calling batch\r\n        const batcherConnection = Object.assign(Object.assign({}, this.connection), { headers: Object.assign(Object.assign({}, this.connection.headers), { 'Alchemy-Ethers-Sdk-Method': 'batchSend' }) });\r\n        const sendBatchFn = (requests) => {\r\n            return fetchJson(batcherConnection, JSON.stringify(requests));\r\n        };\r\n        this.batcher = new RequestBatcher(sendBatchFn);\r\n    }\r\n    /**\r\n     * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\r\n     * ethers.js. Returns the API key for an Alchemy provider.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getApiKey(apiKey) {\r\n        if (apiKey == null) {\r\n            return DEFAULT_ALCHEMY_API_KEY;\r\n        }\r\n        if (apiKey && typeof apiKey !== 'string') {\r\n            throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);\r\n        }\r\n        return apiKey;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in CustomNetworks) {\r\n            return CustomNetworks[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return getNetwork(network);\r\n    }\r\n    /**\r\n     * Converts the `Networkish` input to the network enum used by Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyNetwork(network) {\r\n        if (network === undefined) {\r\n            return DEFAULT_NETWORK;\r\n        }\r\n        if (typeof network === 'number') {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be a string.`);\r\n        }\r\n        // Guaranteed that `typeof network === 'string`.\r\n        const isValidNetwork = Object.values(Network).includes(network);\r\n        if (!isValidNetwork) {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be one of: ` +\r\n                `${Object.values(Network).join(', ')}.`);\r\n        }\r\n        return network;\r\n    }\r\n    /**\r\n     * Returns a {@link ConnectionInfo} object compatible with ethers that contains\r\n     * the correct URLs for Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyConnectionInfo(network, apiKey, type) {\r\n        const url = type === 'http'\r\n            ? getAlchemyHttpUrl(network, apiKey)\r\n            : getAlchemyWsUrl(network, apiKey);\r\n        return {\r\n            headers: IS_BROWSER\r\n                ? {\r\n                    'Alchemy-Ethers-Sdk-Version': VERSION\r\n                }\r\n                : {\r\n                    'Alchemy-Ethers-Sdk-Version': VERSION,\r\n                    'Accept-Encoding': 'gzip'\r\n                },\r\n            allowGzip: true,\r\n            url\r\n        };\r\n    }\r\n    /**\r\n     * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\r\n     * method is called when calling methods on the parent class `BaseProvider`.\r\n     *\r\n     * @override\r\n     */\r\n    detectNetwork() {\r\n        const _super = Object.create(null, {\r\n            detectNetwork: { get: () => super.detectNetwork }\r\n        });\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let network = this.network;\r\n            if (network == null) {\r\n                network = yield _super.detectNetwork.call(this);\r\n                if (!network) {\r\n                    throw new Error('No network detected');\r\n                }\r\n            }\r\n            return network;\r\n        });\r\n    }\r\n    _startPending() {\r\n        logWarn('WARNING: Alchemy Provider does not support pending filters');\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\r\n    }\r\n    /**\r\n     * Overrides the base {@link JsonRpcProvider.send} method to implement custom\r\n     * logic for sending requests to Alchemy.\r\n     *\r\n     * @param method The method name to use for the request.\r\n     * @param params The parameters to use for the request.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Add headers for `perform()` override.\r\n    send(method, params) {\r\n        return this._send(method, params, 'send');\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `JsonRpcProvider.send()`.\r\n     *\r\n     * This method is copied over directly in order to implement custom headers\r\n     *\r\n     * @internal\r\n     */\r\n    _send(method, params, methodName, forceBatch = false) {\r\n        const request = {\r\n            method,\r\n            params,\r\n            id: this._nextId++,\r\n            jsonrpc: '2.0'\r\n        };\r\n        // START MODIFIED CODE\r\n        const connection = Object.assign({}, this.connection);\r\n        connection.headers['Alchemy-Ethers-Sdk-Method'] = methodName;\r\n        if (this.batchRequests || forceBatch) {\r\n            return this.batcher.enqueueRequest(request);\r\n        }\r\n        // END MODIFIED CODE\r\n        this.emit('debug', {\r\n            action: 'request',\r\n            request: deepCopy(request),\r\n            provider: this\r\n        });\r\n        // We can expand this in the future to any call, but for now these\r\n        // are the biggest wins and do not require any serializing parameters.\r\n        const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\r\n        if (cache && this._cache[method]) {\r\n            return this._cache[method];\r\n        }\r\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then(result => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                request,\r\n                response: result,\r\n                provider: this\r\n            });\r\n            return result;\r\n        }, error => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                error,\r\n                request,\r\n                provider: this\r\n            });\r\n            throw error;\r\n        });\r\n        // Cache the fetch, but clear it on the next event loop\r\n        if (cache) {\r\n            this._cache[method] = result;\r\n            setTimeout(() => {\r\n                // @ts-ignore - This is done by ethers.\r\n                this._cache[method] = null;\r\n            }, 0);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Original code copied over from ether.js's\r\n * `@ethersproject/web/src.ts/index.ts`. Used to support\r\n * {@link AlchemyProvider._send}, which is also copied over.\r\n */\r\nfunction getResult(payload) {\r\n    if (payload.error) {\r\n        const error = new Error(payload.error.message);\r\n        error.code = payload.error.code;\r\n        error.data = payload.error.data;\r\n        throw error;\r\n    }\r\n    return payload.result;\r\n}\n\nexport { AlchemyProvider };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}