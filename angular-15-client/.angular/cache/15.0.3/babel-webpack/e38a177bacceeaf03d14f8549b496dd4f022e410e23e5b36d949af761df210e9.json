{"ast":null,"code":"\"use strict\";\n\nimport { formatFixed, parseFixed } from \"@ethersproject/bignumber\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst names = [\"wei\", \"kwei\", \"mwei\", \"gwei\", \"szabo\", \"finney\", \"ether\"];\n// Some environments have issues with RegEx that contain back-tracking, so we cannot\n// use them.\nexport function commify(value) {\n  const comps = String(value).split(\".\");\n  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === \".\" || value === \"-.\") {\n    logger.throwArgumentError(\"invalid value\", \"value\", value);\n  }\n  // Make sure we have at least one whole digit (0 if none)\n  let whole = comps[0];\n  let negative = \"\";\n  if (whole.substring(0, 1) === \"-\") {\n    negative = \"-\";\n    whole = whole.substring(1);\n  }\n  // Make sure we have at least 1 whole digit with no leading zeros\n  while (whole.substring(0, 1) === \"0\") {\n    whole = whole.substring(1);\n  }\n  if (whole === \"\") {\n    whole = \"0\";\n  }\n  let suffix = \"\";\n  if (comps.length === 2) {\n    suffix = \".\" + (comps[1] || \"0\");\n  }\n  while (suffix.length > 2 && suffix[suffix.length - 1] === \"0\") {\n    suffix = suffix.substring(0, suffix.length - 1);\n  }\n  const formatted = [];\n  while (whole.length) {\n    if (whole.length <= 3) {\n      formatted.unshift(whole);\n      break;\n    } else {\n      const index = whole.length - 3;\n      formatted.unshift(whole.substring(index));\n      whole = whole.substring(0, index);\n    }\n  }\n  return negative + formatted.join(\",\") + suffix;\n}\nexport function formatUnits(value, unitName) {\n  if (typeof unitName === \"string\") {\n    const index = names.indexOf(unitName);\n    if (index !== -1) {\n      unitName = 3 * index;\n    }\n  }\n  return formatFixed(value, unitName != null ? unitName : 18);\n}\nexport function parseUnits(value, unitName) {\n  if (typeof value !== \"string\") {\n    logger.throwArgumentError(\"value must be a string\", \"value\", value);\n  }\n  if (typeof unitName === \"string\") {\n    const index = names.indexOf(unitName);\n    if (index !== -1) {\n      unitName = 3 * index;\n    }\n  }\n  return parseFixed(value, unitName != null ? unitName : 18);\n}\nexport function formatEther(wei) {\n  return formatUnits(wei, 18);\n}\nexport function parseEther(ether) {\n  return parseUnits(ether, 18);\n}","map":{"version":3,"names":["formatFixed","parseFixed","Logger","version","logger","names","commify","value","comps","String","split","length","match","throwArgumentError","whole","negative","substring","suffix","formatted","unshift","index","join","formatUnits","unitName","indexOf","parseUnits","formatEther","wei","parseEther","ether"],"sources":["F:/DDesktop/MEAN_BC/mean-stack-authentication-authorization-master/angular-15-client/node_modules/@ethersproject/units/lib.esm/index.js"],"sourcesContent":["\"use strict\";\nimport { formatFixed, parseFixed } from \"@ethersproject/bignumber\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n// Some environments have issues with RegEx that contain back-tracking, so we cannot\n// use them.\nexport function commify(value) {\n    const comps = String(value).split(\".\");\n    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === \".\" || value === \"-.\") {\n        logger.throwArgumentError(\"invalid value\", \"value\", value);\n    }\n    // Make sure we have at least one whole digit (0 if none)\n    let whole = comps[0];\n    let negative = \"\";\n    if (whole.substring(0, 1) === \"-\") {\n        negative = \"-\";\n        whole = whole.substring(1);\n    }\n    // Make sure we have at least 1 whole digit with no leading zeros\n    while (whole.substring(0, 1) === \"0\") {\n        whole = whole.substring(1);\n    }\n    if (whole === \"\") {\n        whole = \"0\";\n    }\n    let suffix = \"\";\n    if (comps.length === 2) {\n        suffix = \".\" + (comps[1] || \"0\");\n    }\n    while (suffix.length > 2 && suffix[suffix.length - 1] === \"0\") {\n        suffix = suffix.substring(0, suffix.length - 1);\n    }\n    const formatted = [];\n    while (whole.length) {\n        if (whole.length <= 3) {\n            formatted.unshift(whole);\n            break;\n        }\n        else {\n            const index = whole.length - 3;\n            formatted.unshift(whole.substring(index));\n            whole = whole.substring(0, index);\n        }\n    }\n    return negative + formatted.join(\",\") + suffix;\n}\nexport function formatUnits(value, unitName) {\n    if (typeof (unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) {\n            unitName = 3 * index;\n        }\n    }\n    return formatFixed(value, (unitName != null) ? unitName : 18);\n}\nexport function parseUnits(value, unitName) {\n    if (typeof (value) !== \"string\") {\n        logger.throwArgumentError(\"value must be a string\", \"value\", value);\n    }\n    if (typeof (unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) {\n            unitName = 3 * index;\n        }\n    }\n    return parseFixed(value, (unitName != null) ? unitName : 18);\n}\nexport function formatEther(wei) {\n    return formatUnits(wei, 18);\n}\nexport function parseEther(ether) {\n    return parseUnits(ether, 18);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}