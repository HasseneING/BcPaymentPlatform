{"ast":null,"code":"import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { ens_normalize } from \"./ens-normalize/lib\";\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n  if (comp.length === 0) {\n    throw new Error(\"invalid ENS name; empty component\");\n  }\n  return comp;\n}\nfunction ensNameSplit(name) {\n  const bytes = toUtf8Bytes(ens_normalize(name));\n  const comps = [];\n  if (name.length === 0) {\n    return comps;\n  }\n  let last = 0;\n  for (let i = 0; i < bytes.length; i++) {\n    const d = bytes[i];\n    // A separator (i.e. \".\"); copy this component\n    if (d === 0x2e) {\n      comps.push(checkComponent(bytes.slice(last, i)));\n      last = i + 1;\n    }\n  }\n  // There was a stray separator at the end of the name\n  if (last >= bytes.length) {\n    throw new Error(\"invalid ENS name; empty component\");\n  }\n  comps.push(checkComponent(bytes.slice(last)));\n  return comps;\n}\nexport function ensNormalize(name) {\n  return ensNameSplit(name).map(comp => toUtf8String(comp)).join(\".\");\n}\nexport function isValidName(name) {\n  try {\n    return ensNameSplit(name).length !== 0;\n  } catch (error) {}\n  return false;\n}\nexport function namehash(name) {\n  /* istanbul ignore if */\n  if (typeof name !== \"string\") {\n    logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n  }\n  let result = Zeros;\n  const comps = ensNameSplit(name);\n  while (comps.length) {\n    result = keccak256(concat([result, keccak256(comps.pop())]));\n  }\n  return hexlify(result);\n}\nexport function dnsEncode(name) {\n  return hexlify(concat(ensNameSplit(name).map(comp => {\n    // DNS does not allow components over 63 bytes in length\n    if (comp.length > 63) {\n      throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n    }\n    const bytes = new Uint8Array(comp.length + 1);\n    bytes.set(comp, 1);\n    bytes[0] = bytes.length - 1;\n    return bytes;\n  }))) + \"00\";\n}","map":{"version":3,"names":["concat","hexlify","toUtf8Bytes","toUtf8String","keccak256","Logger","version","logger","ens_normalize","Zeros","Uint8Array","fill","checkComponent","comp","length","Error","ensNameSplit","name","bytes","comps","last","i","d","push","slice","ensNormalize","map","join","isValidName","error","namehash","throwArgumentError","result","pop","dnsEncode","set"],"sources":["F:/DDesktop/MEAN_BC/mean-stack-authentication-authorization-master/angular-15-client/node_modules/@ethersproject/hash/lib.esm/namehash.js"],"sourcesContent":["import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { ens_normalize } from \"./ens-normalize/lib\";\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    if (comp.length === 0) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = toUtf8Bytes(ens_normalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    if (last >= bytes.length) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\nexport function ensNormalize(name) {\n    return ensNameSplit(name).map((comp) => toUtf8String(comp)).join(\".\");\n}\nexport function isValidName(name) {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    }\n    catch (error) { }\n    return false;\n}\nexport function namehash(name) {\n    /* istanbul ignore if */\n    if (typeof (name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = keccak256(concat([result, keccak256(comps.pop())]));\n    }\n    return hexlify(result);\n}\nexport function dnsEncode(name) {\n    return hexlify(concat(ensNameSplit(name).map((comp) => {\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}