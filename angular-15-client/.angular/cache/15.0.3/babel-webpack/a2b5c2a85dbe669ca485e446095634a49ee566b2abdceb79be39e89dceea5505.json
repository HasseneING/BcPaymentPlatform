{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction now() {\n  return new Date().getTime();\n}\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n  let result = null;\n  for (let i = 0; i < networks.length; i++) {\n    const network = networks[i];\n    // Null! We do not know our network; bail.\n    if (network == null) {\n      return null;\n    }\n    if (result) {\n      // Make sure the network matches the previous networks\n      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {\n        logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n      }\n    } else {\n      result = network;\n    }\n  }\n  return result;\n}\nfunction median(values, maxDelta) {\n  values = values.slice().sort();\n  const middle = Math.floor(values.length / 2);\n  // Odd length; take the middle\n  if (values.length % 2) {\n    return values[middle];\n  }\n  // Even length; take the average of the two middle\n  const a = values[middle - 1],\n    b = values[middle];\n  if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n    return null;\n  }\n  return (a + b) / 2;\n}\nfunction serialize(value) {\n  if (value === null) {\n    return \"null\";\n  } else if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return JSON.stringify(value);\n  } else if (typeof value === \"string\") {\n    return value;\n  } else if (BigNumber.isBigNumber(value)) {\n    return value.toString();\n  } else if (Array.isArray(value)) {\n    return JSON.stringify(value.map(i => serialize(i)));\n  } else if (typeof value === \"object\") {\n    const keys = Object.keys(value);\n    keys.sort();\n    return \"{\" + keys.map(key => {\n      let v = value[key];\n      if (typeof v === \"function\") {\n        v = \"[function]\";\n      } else {\n        v = serialize(v);\n      }\n      return JSON.stringify(key) + \":\" + v;\n    }).join(\",\") + \"}\";\n  }\n  throw new Error(\"unknown value type: \" + typeof value);\n}\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n;\nfunction stall(duration) {\n  let cancel = null;\n  let timer = null;\n  let promise = new Promise(resolve => {\n    cancel = function () {\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n      resolve();\n    };\n    timer = setTimeout(cancel, duration);\n  });\n  const wait = func => {\n    promise = promise.then(func);\n    return promise;\n  };\n  function getPromise() {\n    return promise;\n  }\n  return {\n    cancel,\n    getPromise,\n    wait\n  };\n}\nconst ForwardErrors = [Logger.errors.CALL_EXCEPTION, Logger.errors.INSUFFICIENT_FUNDS, Logger.errors.NONCE_EXPIRED, Logger.errors.REPLACEMENT_UNDERPRICED, Logger.errors.UNPREDICTABLE_GAS_LIMIT];\nconst ForwardProperties = [\"address\", \"args\", \"errorArgs\", \"errorSignature\", \"method\", \"transaction\"];\n;\nfunction exposeDebugConfig(config, now) {\n  const result = {\n    weight: config.weight\n  };\n  Object.defineProperty(result, \"provider\", {\n    get: () => config.provider\n  });\n  if (config.start) {\n    result.start = config.start;\n  }\n  if (now) {\n    result.duration = now - config.start;\n  }\n  if (config.done) {\n    if (config.error) {\n      result.error = config.error;\n    } else {\n      result.result = config.result || null;\n    }\n  }\n  return result;\n}\nfunction normalizedTally(normalize, quorum) {\n  return function (configs) {\n    // Count the votes for each result\n    const tally = {};\n    configs.forEach(c => {\n      const value = normalize(c.result);\n      if (!tally[value]) {\n        tally[value] = {\n          count: 0,\n          result: c.result\n        };\n      }\n      tally[value].count++;\n    });\n    // Check for a quorum on any given result\n    const keys = Object.keys(tally);\n    for (let i = 0; i < keys.length; i++) {\n      const check = tally[keys[i]];\n      if (check.count >= quorum) {\n        return check.result;\n      }\n    }\n    // No quroum\n    return undefined;\n  };\n}\nfunction getProcessFunc(provider, method, params) {\n  let normalize = serialize;\n  switch (method) {\n    case \"getBlockNumber\":\n      // Return the median value, unless there is (median + 1) is also\n      // present, in which case that is probably true and the median\n      // is going to be stale soon. In the event of a malicious node,\n      // the lie will be true soon enough.\n      return function (configs) {\n        const values = configs.map(c => c.result);\n        // Get the median block number\n        let blockNumber = median(configs.map(c => c.result), 2);\n        if (blockNumber == null) {\n          return undefined;\n        }\n        blockNumber = Math.ceil(blockNumber);\n        // If the next block height is present, its prolly safe to use\n        if (values.indexOf(blockNumber + 1) >= 0) {\n          blockNumber++;\n        }\n        // Don't ever roll back the blockNumber\n        if (blockNumber >= provider._highestBlockNumber) {\n          provider._highestBlockNumber = blockNumber;\n        }\n        return provider._highestBlockNumber;\n      };\n    case \"getGasPrice\":\n      // Return the middle (round index up) value, similar to median\n      // but do not average even entries and choose the higher.\n      // Malicious actors must compromise 50% of the nodes to lie.\n      return function (configs) {\n        const values = configs.map(c => c.result);\n        values.sort();\n        return values[Math.floor(values.length / 2)];\n      };\n    case \"getEtherPrice\":\n      // Returns the median price. Malicious actors must compromise at\n      // least 50% of the nodes to lie (in a meaningful way).\n      return function (configs) {\n        return median(configs.map(c => c.result));\n      };\n    // No additional normalizing required; serialize is enough\n    case \"getBalance\":\n    case \"getTransactionCount\":\n    case \"getCode\":\n    case \"getStorageAt\":\n    case \"call\":\n    case \"estimateGas\":\n    case \"getLogs\":\n      break;\n    // We drop the confirmations from transactions as it is approximate\n    case \"getTransaction\":\n    case \"getTransactionReceipt\":\n      normalize = function (tx) {\n        if (tx == null) {\n          return null;\n        }\n        tx = shallowCopy(tx);\n        tx.confirmations = -1;\n        return serialize(tx);\n      };\n      break;\n    // We drop the confirmations from transactions as it is approximate\n    case \"getBlock\":\n      // We drop the confirmations from transactions as it is approximate\n      if (params.includeTransactions) {\n        normalize = function (block) {\n          if (block == null) {\n            return null;\n          }\n          block = shallowCopy(block);\n          block.transactions = block.transactions.map(tx => {\n            tx = shallowCopy(tx);\n            tx.confirmations = -1;\n            return tx;\n          });\n          return serialize(block);\n        };\n      } else {\n        normalize = function (block) {\n          if (block == null) {\n            return null;\n          }\n          return serialize(block);\n        };\n      }\n      break;\n    default:\n      throw new Error(\"unknown method: \" + method);\n  }\n  // Return the result if and only if the expected quorum is\n  // satisfied and agreed upon for the final result.\n  return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const provider = config.provider;\n    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {\n      return provider;\n    }\n    return poll(() => {\n      return new Promise((resolve, reject) => {\n        setTimeout(function () {\n          // We are synced\n          if (provider.blockNumber >= blockNumber) {\n            return resolve(provider);\n          }\n          // We're done; just quit\n          if (config.cancelled) {\n            return resolve(null);\n          }\n          // Try again, next block\n          return resolve(undefined);\n        }, 0);\n      });\n    }, {\n      oncePoll: provider\n    });\n  });\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let provider = config.provider;\n    switch (method) {\n      case \"getBlockNumber\":\n      case \"getGasPrice\":\n        return provider[method]();\n      case \"getEtherPrice\":\n        if (provider.getEtherPrice) {\n          return provider.getEtherPrice();\n        }\n        break;\n      case \"getBalance\":\n      case \"getTransactionCount\":\n      case \"getCode\":\n        if (params.blockTag && isHexString(params.blockTag)) {\n          provider = yield waitForSync(config, currentBlockNumber);\n        }\n        return provider[method](params.address, params.blockTag || \"latest\");\n      case \"getStorageAt\":\n        if (params.blockTag && isHexString(params.blockTag)) {\n          provider = yield waitForSync(config, currentBlockNumber);\n        }\n        return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n      case \"getBlock\":\n        if (params.blockTag && isHexString(params.blockTag)) {\n          provider = yield waitForSync(config, currentBlockNumber);\n        }\n        return provider[params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\"](params.blockTag || params.blockHash);\n      case \"call\":\n      case \"estimateGas\":\n        if (params.blockTag && isHexString(params.blockTag)) {\n          provider = yield waitForSync(config, currentBlockNumber);\n        }\n        if (method === \"call\" && params.blockTag) {\n          return provider[method](params.transaction, params.blockTag);\n        }\n        return provider[method](params.transaction);\n      case \"getTransaction\":\n      case \"getTransactionReceipt\":\n        return provider[method](params.transactionHash);\n      case \"getLogs\":\n        {\n          let filter = params.filter;\n          if (filter.fromBlock && isHexString(filter.fromBlock) || filter.toBlock && isHexString(filter.toBlock)) {\n            provider = yield waitForSync(config, currentBlockNumber);\n          }\n          return provider.getLogs(filter);\n        }\n    }\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n      method: method,\n      params: params\n    });\n  });\n}\nexport class FallbackProvider extends BaseProvider {\n  constructor(providers, quorum) {\n    if (providers.length === 0) {\n      logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n    }\n    const providerConfigs = providers.map((configOrProvider, index) => {\n      if (Provider.isProvider(configOrProvider)) {\n        const stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n        const priority = 1;\n        return Object.freeze({\n          provider: configOrProvider,\n          weight: 1,\n          stallTimeout,\n          priority\n        });\n      }\n      const config = shallowCopy(configOrProvider);\n      if (config.priority == null) {\n        config.priority = 1;\n      }\n      if (config.stallTimeout == null) {\n        config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n      }\n      if (config.weight == null) {\n        config.weight = 1;\n      }\n      const weight = config.weight;\n      if (weight % 1 || weight > 512 || weight < 1) {\n        logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n      }\n      return Object.freeze(config);\n    });\n    const total = providerConfigs.reduce((accum, c) => accum + c.weight, 0);\n    if (quorum == null) {\n      quorum = total / 2;\n    } else if (quorum > total) {\n      logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n    }\n    // Are all providers' networks are known\n    let networkOrReady = checkNetworks(providerConfigs.map(c => c.provider.network));\n    // Not all networks are known; we must stall\n    if (networkOrReady == null) {\n      networkOrReady = new Promise((resolve, reject) => {\n        setTimeout(() => {\n          this.detectNetwork().then(resolve, reject);\n        }, 0);\n      });\n    }\n    super(networkOrReady);\n    // Preserve a copy, so we do not get mutated\n    defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n    defineReadOnly(this, \"quorum\", quorum);\n    this._highestBlockNumber = -1;\n  }\n  detectNetwork() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const networks = yield Promise.all(this.providerConfigs.map(c => c.provider.getNetwork()));\n      return checkNetworks(networks);\n    });\n  }\n  perform(method, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Sending transactions is special; always broadcast it to all backends\n      if (method === \"sendTransaction\") {\n        const results = yield Promise.all(this.providerConfigs.map(c => {\n          return c.provider.sendTransaction(params.signedTransaction).then(result => {\n            return result.hash;\n          }, error => {\n            return error;\n          });\n        }));\n        // Any success is good enough (other errors are likely \"already seen\" errors\n        for (let i = 0; i < results.length; i++) {\n          const result = results[i];\n          if (typeof result === \"string\") {\n            return result;\n          }\n        }\n        // They were all an error; pick the first error\n        throw results[0];\n      }\n      // We need to make sure we are in sync with our backends, so we need\n      // to know this before we can make a lot of calls\n      if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n        yield this.getBlockNumber();\n      }\n      const processFunc = getProcessFunc(this, method, params);\n      // Shuffle the providers and then sort them by their priority; we\n      // shallowCopy them since we will store the result in them too\n      const configs = shuffled(this.providerConfigs.map(shallowCopy));\n      configs.sort((a, b) => a.priority - b.priority);\n      const currentBlockNumber = this._highestBlockNumber;\n      let i = 0;\n      let first = true;\n      while (true) {\n        const t0 = now();\n        // Compute the inflight weight (exclude anything past)\n        let inflightWeight = configs.filter(c => c.runner && t0 - c.start < c.stallTimeout).reduce((accum, c) => accum + c.weight, 0);\n        // Start running enough to meet quorum\n        while (inflightWeight < this.quorum && i < configs.length) {\n          const config = configs[i++];\n          const rid = nextRid++;\n          config.start = now();\n          config.staller = stall(config.stallTimeout);\n          config.staller.wait(() => {\n            config.staller = null;\n          });\n          config.runner = getRunner(config, currentBlockNumber, method, params).then(result => {\n            config.done = true;\n            config.result = result;\n            if (this.listenerCount(\"debug\")) {\n              this.emit(\"debug\", {\n                action: \"request\",\n                rid: rid,\n                backend: exposeDebugConfig(config, now()),\n                request: {\n                  method: method,\n                  params: deepCopy(params)\n                },\n                provider: this\n              });\n            }\n          }, error => {\n            config.done = true;\n            config.error = error;\n            if (this.listenerCount(\"debug\")) {\n              this.emit(\"debug\", {\n                action: \"request\",\n                rid: rid,\n                backend: exposeDebugConfig(config, now()),\n                request: {\n                  method: method,\n                  params: deepCopy(params)\n                },\n                provider: this\n              });\n            }\n          });\n          if (this.listenerCount(\"debug\")) {\n            this.emit(\"debug\", {\n              action: \"request\",\n              rid: rid,\n              backend: exposeDebugConfig(config, null),\n              request: {\n                method: method,\n                params: deepCopy(params)\n              },\n              provider: this\n            });\n          }\n          inflightWeight += config.weight;\n        }\n        // Wait for anything meaningful to finish or stall out\n        const waiting = [];\n        configs.forEach(c => {\n          if (c.done || !c.runner) {\n            return;\n          }\n          waiting.push(c.runner);\n          if (c.staller) {\n            waiting.push(c.staller.getPromise());\n          }\n        });\n        if (waiting.length) {\n          yield Promise.race(waiting);\n        }\n        // Check the quorum and process the results; the process function\n        // may additionally decide the quorum is not met\n        const results = configs.filter(c => c.done && c.error == null);\n        if (results.length >= this.quorum) {\n          const result = processFunc(results);\n          if (result !== undefined) {\n            // Shut down any stallers\n            configs.forEach(c => {\n              if (c.staller) {\n                c.staller.cancel();\n              }\n              c.cancelled = true;\n            });\n            return result;\n          }\n          if (!first) {\n            yield stall(100).getPromise();\n          }\n          first = false;\n        }\n        // No result, check for errors that should be forwarded\n        const errors = configs.reduce((accum, c) => {\n          if (!c.done || c.error == null) {\n            return accum;\n          }\n          const code = c.error.code;\n          if (ForwardErrors.indexOf(code) >= 0) {\n            if (!accum[code]) {\n              accum[code] = {\n                error: c.error,\n                weight: 0\n              };\n            }\n            accum[code].weight += c.weight;\n          }\n          return accum;\n        }, {});\n        Object.keys(errors).forEach(errorCode => {\n          const tally = errors[errorCode];\n          if (tally.weight < this.quorum) {\n            return;\n          }\n          // Shut down any stallers\n          configs.forEach(c => {\n            if (c.staller) {\n              c.staller.cancel();\n            }\n            c.cancelled = true;\n          });\n          const e = tally.error;\n          const props = {};\n          ForwardProperties.forEach(name => {\n            if (e[name] == null) {\n              return;\n            }\n            props[name] = e[name];\n          });\n          logger.throwError(e.reason || e.message, errorCode, props);\n        });\n        // All configs have run to completion; we will never get more data\n        if (configs.filter(c => !c.done).length === 0) {\n          break;\n        }\n      }\n      // Shut down any stallers; shouldn't be any\n      configs.forEach(c => {\n        if (c.staller) {\n          c.staller.cancel();\n        }\n        c.cancelled = true;\n      });\n      return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n        method: method,\n        params: params,\n        //results: configs.map((c) => c.result),\n        //errors: configs.map((c) => c.error),\n        results: configs.map(c => exposeDebugConfig(c)),\n        provider: this\n      });\n    });\n  }\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Provider","BigNumber","isHexString","deepCopy","defineReadOnly","shallowCopy","shuffled","poll","BaseProvider","isCommunityResource","Logger","version","logger","now","Date","getTime","checkNetworks","networks","i","length","network","name","chainId","ensAddress","throwArgumentError","median","values","maxDelta","slice","sort","middle","Math","floor","a","b","abs","serialize","JSON","stringify","isBigNumber","toString","Array","isArray","map","keys","Object","key","v","join","Error","nextRid","stall","duration","cancel","timer","promise","clearTimeout","setTimeout","wait","func","getPromise","ForwardErrors","errors","CALL_EXCEPTION","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","UNPREDICTABLE_GAS_LIMIT","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","get","provider","start","error","normalizedTally","normalize","quorum","configs","tally","forEach","c","count","check","undefined","getProcessFunc","method","params","blockNumber","ceil","indexOf","_highestBlockNumber","tx","confirmations","includeTransactions","block","transactions","waitForSync","cancelled","oncePoll","getRunner","currentBlockNumber","getEtherPrice","blockTag","address","getStorageAt","position","blockHash","transaction","transactionHash","filter","fromBlock","toBlock","getLogs","throwError","UNKNOWN_ERROR","FallbackProvider","constructor","providers","providerConfigs","configOrProvider","index","isProvider","stallTimeout","priority","freeze","total","reduce","accum","networkOrReady","detectNetwork","all","getNetwork","perform","results","sendTransaction","signedTransaction","hash","getBlockNumber","processFunc","first","t0","inflightWeight","runner","rid","staller","listenerCount","emit","action","backend","request","waiting","push","race","code","errorCode","props","reason","message","SERVER_ERROR"],"sources":["F:/DDesktop/MEAN_BC/mean-stack-authentication-authorization-master/angular-15-client/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction now() { return (new Date()).getTime(); }\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n    let result = null;\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n        // Null! We do not know our network; bail.\n        if (network == null) {\n            return null;\n        }\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n            }\n        }\n        else {\n            result = network;\n        }\n    }\n    return result;\n}\nfunction median(values, maxDelta) {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n    return (a + b) / 2;\n}\nfunction serialize(value) {\n    if (value === null) {\n        return \"null\";\n    }\n    else if (typeof (value) === \"number\" || typeof (value) === \"boolean\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof (value) === \"string\") {\n        return value;\n    }\n    else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    }\n    else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    }\n    else if (typeof (value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof (v) === \"function\") {\n                v = \"[function]\";\n            }\n            else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n    throw new Error(\"unknown value type: \" + typeof (value));\n}\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n;\nfunction stall(duration) {\n    let cancel = null;\n    let timer = null;\n    let promise = (new Promise((resolve) => {\n        cancel = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        };\n        timer = setTimeout(cancel, duration);\n    }));\n    const wait = (func) => {\n        promise = promise.then(func);\n        return promise;\n    };\n    function getPromise() {\n        return promise;\n    }\n    return { cancel, getPromise, wait };\n}\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n;\nfunction exposeDebugConfig(config, now) {\n    const result = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) {\n        result.start = config.start;\n    }\n    if (now) {\n        result.duration = (now - config.start);\n    }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        }\n        else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\nfunction normalizedTally(normalize, quorum) {\n    return function (configs) {\n        // Count the votes for each result\n        const tally = {};\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) {\n                tally[value] = { count: 0, result: c.result };\n            }\n            tally[value].count++;\n        });\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n        // No quroum\n        return undefined;\n    };\n}\nfunction getProcessFunc(provider, method, params) {\n    let normalize = serialize;\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) {\n                    return undefined;\n                }\n                blockNumber = Math.ceil(blockNumber);\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) {\n                    blockNumber++;\n                }\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n                return provider._highestBlockNumber;\n            };\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            };\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function (configs) {\n                return median(configs.map((c) => c.result));\n            };\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function (tx) {\n                if (tx == null) {\n                    return null;\n                }\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            };\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            }\n            else {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    return serialize(block);\n                };\n            }\n            break;\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const provider = (config.provider);\n        if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n            return provider;\n        }\n        return poll(() => {\n            return new Promise((resolve, reject) => {\n                setTimeout(function () {\n                    // We are synced\n                    if (provider.blockNumber >= blockNumber) {\n                        return resolve(provider);\n                    }\n                    // We're done; just quit\n                    if (config.cancelled) {\n                        return resolve(null);\n                    }\n                    // Try again, next block\n                    return resolve(undefined);\n                }, 0);\n            });\n        }, { oncePoll: provider });\n    });\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let provider = config.provider;\n        switch (method) {\n            case \"getBlockNumber\":\n            case \"getGasPrice\":\n                return provider[method]();\n            case \"getEtherPrice\":\n                if (provider.getEtherPrice) {\n                    return provider.getEtherPrice();\n                }\n                break;\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.address, params.blockTag || \"latest\");\n            case \"getStorageAt\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n            case \"getBlock\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[(params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\")](params.blockTag || params.blockHash);\n            case \"call\":\n            case \"estimateGas\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                if (method === \"call\" && params.blockTag) {\n                    return provider[method](params.transaction, params.blockTag);\n                }\n                return provider[method](params.transaction);\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n                return provider[method](params.transactionHash);\n            case \"getLogs\": {\n                let filter = params.filter;\n                if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getLogs(filter);\n            }\n        }\n        return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n            method: method,\n            params: params\n        });\n    });\n}\nexport class FallbackProvider extends BaseProvider {\n    constructor(providers, quorum) {\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n        const providerConfigs = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n            const config = shallowCopy(configOrProvider);\n            if (config.priority == null) {\n                config.priority = 1;\n            }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n            }\n            if (config.weight == null) {\n                config.weight = 1;\n            }\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n            }\n            return Object.freeze(config);\n        });\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n        if (quorum == null) {\n            quorum = total / 2;\n        }\n        else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n        // Are all providers' networks are known\n        let networkOrReady = checkNetworks(providerConfigs.map((c) => (c.provider).network));\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n        this._highestBlockNumber = -1;\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const networks = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n            return checkNetworks(networks);\n        });\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sending transactions is special; always broadcast it to all backends\n            if (method === \"sendTransaction\") {\n                const results = yield Promise.all(this.providerConfigs.map((c) => {\n                    return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                        return result.hash;\n                    }, (error) => {\n                        return error;\n                    });\n                }));\n                // Any success is good enough (other errors are likely \"already seen\" errors\n                for (let i = 0; i < results.length; i++) {\n                    const result = results[i];\n                    if (typeof (result) === \"string\") {\n                        return result;\n                    }\n                }\n                // They were all an error; pick the first error\n                throw results[0];\n            }\n            // We need to make sure we are in sync with our backends, so we need\n            // to know this before we can make a lot of calls\n            if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n                yield this.getBlockNumber();\n            }\n            const processFunc = getProcessFunc(this, method, params);\n            // Shuffle the providers and then sort them by their priority; we\n            // shallowCopy them since we will store the result in them too\n            const configs = shuffled(this.providerConfigs.map(shallowCopy));\n            configs.sort((a, b) => (a.priority - b.priority));\n            const currentBlockNumber = this._highestBlockNumber;\n            let i = 0;\n            let first = true;\n            while (true) {\n                const t0 = now();\n                // Compute the inflight weight (exclude anything past)\n                let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                    .reduce((accum, c) => (accum + c.weight), 0);\n                // Start running enough to meet quorum\n                while (inflightWeight < this.quorum && i < configs.length) {\n                    const config = configs[i++];\n                    const rid = nextRid++;\n                    config.start = now();\n                    config.staller = stall(config.stallTimeout);\n                    config.staller.wait(() => { config.staller = null; });\n                    config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                        config.done = true;\n                        config.result = result;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    }, (error) => {\n                        config.done = true;\n                        config.error = error;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    });\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, null),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                    inflightWeight += config.weight;\n                }\n                // Wait for anything meaningful to finish or stall out\n                const waiting = [];\n                configs.forEach((c) => {\n                    if (c.done || !c.runner) {\n                        return;\n                    }\n                    waiting.push(c.runner);\n                    if (c.staller) {\n                        waiting.push(c.staller.getPromise());\n                    }\n                });\n                if (waiting.length) {\n                    yield Promise.race(waiting);\n                }\n                // Check the quorum and process the results; the process function\n                // may additionally decide the quorum is not met\n                const results = configs.filter((c) => (c.done && c.error == null));\n                if (results.length >= this.quorum) {\n                    const result = processFunc(results);\n                    if (result !== undefined) {\n                        // Shut down any stallers\n                        configs.forEach(c => {\n                            if (c.staller) {\n                                c.staller.cancel();\n                            }\n                            c.cancelled = true;\n                        });\n                        return result;\n                    }\n                    if (!first) {\n                        yield stall(100).getPromise();\n                    }\n                    first = false;\n                }\n                // No result, check for errors that should be forwarded\n                const errors = configs.reduce((accum, c) => {\n                    if (!c.done || c.error == null) {\n                        return accum;\n                    }\n                    const code = (c.error).code;\n                    if (ForwardErrors.indexOf(code) >= 0) {\n                        if (!accum[code]) {\n                            accum[code] = { error: c.error, weight: 0 };\n                        }\n                        accum[code].weight += c.weight;\n                    }\n                    return accum;\n                }, ({}));\n                Object.keys(errors).forEach((errorCode) => {\n                    const tally = errors[errorCode];\n                    if (tally.weight < this.quorum) {\n                        return;\n                    }\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) {\n                            c.staller.cancel();\n                        }\n                        c.cancelled = true;\n                    });\n                    const e = (tally.error);\n                    const props = {};\n                    ForwardProperties.forEach((name) => {\n                        if (e[name] == null) {\n                            return;\n                        }\n                        props[name] = e[name];\n                    });\n                    logger.throwError(e.reason || e.message, errorCode, props);\n                });\n                // All configs have run to completion; we will never get more data\n                if (configs.filter((c) => !c.done).length === 0) {\n                    break;\n                }\n            }\n            // Shut down any stallers; shouldn't be any\n            configs.forEach(c => {\n                if (c.staller) {\n                    c.staller.cancel();\n                }\n                c.cancelled = true;\n            });\n            return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n                method: method,\n                params: params,\n                //results: configs.map((c) => c.result),\n                //errors: configs.map((c) => c.error),\n                results: configs.map((c) => exposeDebugConfig(c)),\n                provider: this\n            });\n        });\n    }\n}\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,SAAS,GAAI,IAAI,IAAI,IAAI,CAACA,SAAS,IAAK,UAAUC,OAAO,EAAEC,UAAU,EAAEC,CAAC,EAAEC,SAAS,EAAE;EACrF,SAASC,KAAK,CAACC,KAAK,EAAE;IAAE,OAAOA,KAAK,YAAYH,CAAC,GAAGG,KAAK,GAAG,IAAIH,CAAC,CAAC,UAAUI,OAAO,EAAE;MAAEA,OAAO,CAACD,KAAK,CAAC;IAAE,CAAC,CAAC;EAAE;EAC3G,OAAO,KAAKH,CAAC,KAAKA,CAAC,GAAGK,OAAO,CAAC,EAAE,UAAUD,OAAO,EAAEE,MAAM,EAAE;IACvD,SAASC,SAAS,CAACJ,KAAK,EAAE;MAAE,IAAI;QAAEK,IAAI,CAACP,SAAS,CAACQ,IAAI,CAACN,KAAK,CAAC,CAAC;MAAE,CAAC,CAAC,OAAOO,CAAC,EAAE;QAAEJ,MAAM,CAACI,CAAC,CAAC;MAAE;IAAE;IAC1F,SAASC,QAAQ,CAACR,KAAK,EAAE;MAAE,IAAI;QAAEK,IAAI,CAACP,SAAS,CAAC,OAAO,CAAC,CAACE,KAAK,CAAC,CAAC;MAAE,CAAC,CAAC,OAAOO,CAAC,EAAE;QAAEJ,MAAM,CAACI,CAAC,CAAC;MAAE;IAAE;IAC7F,SAASF,IAAI,CAACI,MAAM,EAAE;MAAEA,MAAM,CAACC,IAAI,GAAGT,OAAO,CAACQ,MAAM,CAACT,KAAK,CAAC,GAAGD,KAAK,CAACU,MAAM,CAACT,KAAK,CAAC,CAACW,IAAI,CAACP,SAAS,EAAEI,QAAQ,CAAC;IAAE;IAC7GH,IAAI,CAAC,CAACP,SAAS,GAAGA,SAAS,CAACc,KAAK,CAACjB,OAAO,EAAEC,UAAU,IAAI,EAAE,CAAC,EAAEU,IAAI,EAAE,CAAC;EACzE,CAAC,CAAC;AACN,CAAC;AACD,SAASO,QAAQ,QAAQ,kCAAkC;AAC3D,SAASC,SAAS,QAAQ,0BAA0B;AACpD,SAASC,WAAW,QAAQ,sBAAsB;AAClD,SAASC,QAAQ,EAAEC,cAAc,EAAEC,WAAW,QAAQ,2BAA2B;AACjF,SAASC,QAAQ,QAAQ,uBAAuB;AAChD,SAASC,IAAI,QAAQ,oBAAoB;AACzC,SAASC,YAAY,QAAQ,iBAAiB;AAC9C,SAASC,mBAAmB,QAAQ,aAAa;AACjD,SAASC,MAAM,QAAQ,uBAAuB;AAC9C,SAASC,OAAO,QAAQ,YAAY;AACpC,MAAMC,MAAM,GAAG,IAAIF,MAAM,CAACC,OAAO,CAAC;AAClC,SAASE,GAAG,GAAG;EAAE,OAAQ,IAAIC,IAAI,EAAE,CAAEC,OAAO,EAAE;AAAE;AAChD;AACA;AACA,SAASC,aAAa,CAACC,QAAQ,EAAE;EAC7B,IAAIrB,MAAM,GAAG,IAAI;EACjB,KAAK,IAAIsB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,QAAQ,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;IACtC,MAAME,OAAO,GAAGH,QAAQ,CAACC,CAAC,CAAC;IAC3B;IACA,IAAIE,OAAO,IAAI,IAAI,EAAE;MACjB,OAAO,IAAI;IACf;IACA,IAAIxB,MAAM,EAAE;MACR;MACA,IAAI,EAAEA,MAAM,CAACyB,IAAI,KAAKD,OAAO,CAACC,IAAI,IAAIzB,MAAM,CAAC0B,OAAO,KAAKF,OAAO,CAACE,OAAO,KAClE1B,MAAM,CAAC2B,UAAU,KAAKH,OAAO,CAACG,UAAU,IAAM3B,MAAM,CAAC2B,UAAU,IAAI,IAAI,IAAIH,OAAO,CAACG,UAAU,IAAI,IAAK,CAAC,CAAC,EAAE;QAC5GX,MAAM,CAACY,kBAAkB,CAAC,mBAAmB,EAAE,UAAU,EAAEP,QAAQ,CAAC;MACxE;IACJ,CAAC,MACI;MACDrB,MAAM,GAAGwB,OAAO;IACpB;EACJ;EACA,OAAOxB,MAAM;AACjB;AACA,SAAS6B,MAAM,CAACC,MAAM,EAAEC,QAAQ,EAAE;EAC9BD,MAAM,GAAGA,MAAM,CAACE,KAAK,EAAE,CAACC,IAAI,EAAE;EAC9B,MAAMC,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACN,MAAM,CAACP,MAAM,GAAG,CAAC,CAAC;EAC5C;EACA,IAAIO,MAAM,CAACP,MAAM,GAAG,CAAC,EAAE;IACnB,OAAOO,MAAM,CAACI,MAAM,CAAC;EACzB;EACA;EACA,MAAMG,CAAC,GAAGP,MAAM,CAACI,MAAM,GAAG,CAAC,CAAC;IAAEI,CAAC,GAAGR,MAAM,CAACI,MAAM,CAAC;EAChD,IAAIH,QAAQ,IAAI,IAAI,IAAII,IAAI,CAACI,GAAG,CAACF,CAAC,GAAGC,CAAC,CAAC,GAAGP,QAAQ,EAAE;IAChD,OAAO,IAAI;EACf;EACA,OAAO,CAACM,CAAC,GAAGC,CAAC,IAAI,CAAC;AACtB;AACA,SAASE,SAAS,CAACjD,KAAK,EAAE;EACtB,IAAIA,KAAK,KAAK,IAAI,EAAE;IAChB,OAAO,MAAM;EACjB,CAAC,MACI,IAAI,OAAQA,KAAM,KAAK,QAAQ,IAAI,OAAQA,KAAM,KAAK,SAAS,EAAE;IAClE,OAAOkD,IAAI,CAACC,SAAS,CAACnD,KAAK,CAAC;EAChC,CAAC,MACI,IAAI,OAAQA,KAAM,KAAK,QAAQ,EAAE;IAClC,OAAOA,KAAK;EAChB,CAAC,MACI,IAAIc,SAAS,CAACsC,WAAW,CAACpD,KAAK,CAAC,EAAE;IACnC,OAAOA,KAAK,CAACqD,QAAQ,EAAE;EAC3B,CAAC,MACI,IAAIC,KAAK,CAACC,OAAO,CAACvD,KAAK,CAAC,EAAE;IAC3B,OAAOkD,IAAI,CAACC,SAAS,CAACnD,KAAK,CAACwD,GAAG,CAAEzB,CAAC,IAAKkB,SAAS,CAAClB,CAAC,CAAC,CAAC,CAAC;EACzD,CAAC,MACI,IAAI,OAAQ/B,KAAM,KAAK,QAAQ,EAAE;IAClC,MAAMyD,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACzD,KAAK,CAAC;IAC/ByD,IAAI,CAACf,IAAI,EAAE;IACX,OAAO,GAAG,GAAGe,IAAI,CAACD,GAAG,CAAEG,GAAG,IAAK;MAC3B,IAAIC,CAAC,GAAG5D,KAAK,CAAC2D,GAAG,CAAC;MAClB,IAAI,OAAQC,CAAE,KAAK,UAAU,EAAE;QAC3BA,CAAC,GAAG,YAAY;MACpB,CAAC,MACI;QACDA,CAAC,GAAGX,SAAS,CAACW,CAAC,CAAC;MACpB;MACA,OAAOV,IAAI,CAACC,SAAS,CAACQ,GAAG,CAAC,GAAG,GAAG,GAAGC,CAAC;IACxC,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG;EACtB;EACA,MAAM,IAAIC,KAAK,CAAC,sBAAsB,GAAG,OAAQ9D,KAAM,CAAC;AAC5D;AACA;AACA,IAAI+D,OAAO,GAAG,CAAC;AACf;AACA,SAASC,KAAK,CAACC,QAAQ,EAAE;EACrB,IAAIC,MAAM,GAAG,IAAI;EACjB,IAAIC,KAAK,GAAG,IAAI;EAChB,IAAIC,OAAO,GAAI,IAAIlE,OAAO,CAAED,OAAO,IAAK;IACpCiE,MAAM,GAAG,YAAY;MACjB,IAAIC,KAAK,EAAE;QACPE,YAAY,CAACF,KAAK,CAAC;QACnBA,KAAK,GAAG,IAAI;MAChB;MACAlE,OAAO,EAAE;IACb,CAAC;IACDkE,KAAK,GAAGG,UAAU,CAACJ,MAAM,EAAED,QAAQ,CAAC;EACxC,CAAC,CAAE;EACH,MAAMM,IAAI,GAAIC,IAAI,IAAK;IACnBJ,OAAO,GAAGA,OAAO,CAACzD,IAAI,CAAC6D,IAAI,CAAC;IAC5B,OAAOJ,OAAO;EAClB,CAAC;EACD,SAASK,UAAU,GAAG;IAClB,OAAOL,OAAO;EAClB;EACA,OAAO;IAAEF,MAAM;IAAEO,UAAU;IAAEF;EAAK,CAAC;AACvC;AACA,MAAMG,aAAa,GAAG,CAClBnD,MAAM,CAACoD,MAAM,CAACC,cAAc,EAC5BrD,MAAM,CAACoD,MAAM,CAACE,kBAAkB,EAChCtD,MAAM,CAACoD,MAAM,CAACG,aAAa,EAC3BvD,MAAM,CAACoD,MAAM,CAACI,uBAAuB,EACrCxD,MAAM,CAACoD,MAAM,CAACK,uBAAuB,CACxC;AACD,MAAMC,iBAAiB,GAAG,CACtB,SAAS,EACT,MAAM,EACN,WAAW,EACX,gBAAgB,EAChB,QAAQ,EACR,aAAa,CAChB;AACD;AACA,SAASC,iBAAiB,CAACC,MAAM,EAAEzD,GAAG,EAAE;EACpC,MAAMjB,MAAM,GAAG;IACX2E,MAAM,EAAED,MAAM,CAACC;EACnB,CAAC;EACD1B,MAAM,CAAC2B,cAAc,CAAC5E,MAAM,EAAE,UAAU,EAAE;IAAE6E,GAAG,EAAE,MAAMH,MAAM,CAACI;EAAS,CAAC,CAAC;EACzE,IAAIJ,MAAM,CAACK,KAAK,EAAE;IACd/E,MAAM,CAAC+E,KAAK,GAAGL,MAAM,CAACK,KAAK;EAC/B;EACA,IAAI9D,GAAG,EAAE;IACLjB,MAAM,CAACwD,QAAQ,GAAIvC,GAAG,GAAGyD,MAAM,CAACK,KAAM;EAC1C;EACA,IAAIL,MAAM,CAACzE,IAAI,EAAE;IACb,IAAIyE,MAAM,CAACM,KAAK,EAAE;MACdhF,MAAM,CAACgF,KAAK,GAAGN,MAAM,CAACM,KAAK;IAC/B,CAAC,MACI;MACDhF,MAAM,CAACA,MAAM,GAAG0E,MAAM,CAAC1E,MAAM,IAAI,IAAI;IACzC;EACJ;EACA,OAAOA,MAAM;AACjB;AACA,SAASiF,eAAe,CAACC,SAAS,EAAEC,MAAM,EAAE;EACxC,OAAO,UAAUC,OAAO,EAAE;IACtB;IACA,MAAMC,KAAK,GAAG,CAAC,CAAC;IAChBD,OAAO,CAACE,OAAO,CAAEC,CAAC,IAAK;MACnB,MAAMhG,KAAK,GAAG2F,SAAS,CAACK,CAAC,CAACvF,MAAM,CAAC;MACjC,IAAI,CAACqF,KAAK,CAAC9F,KAAK,CAAC,EAAE;QACf8F,KAAK,CAAC9F,KAAK,CAAC,GAAG;UAAEiG,KAAK,EAAE,CAAC;UAAExF,MAAM,EAAEuF,CAAC,CAACvF;QAAO,CAAC;MACjD;MACAqF,KAAK,CAAC9F,KAAK,CAAC,CAACiG,KAAK,EAAE;IACxB,CAAC,CAAC;IACF;IACA,MAAMxC,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACqC,KAAK,CAAC;IAC/B,KAAK,IAAI/D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0B,IAAI,CAACzB,MAAM,EAAED,CAAC,EAAE,EAAE;MAClC,MAAMmE,KAAK,GAAGJ,KAAK,CAACrC,IAAI,CAAC1B,CAAC,CAAC,CAAC;MAC5B,IAAImE,KAAK,CAACD,KAAK,IAAIL,MAAM,EAAE;QACvB,OAAOM,KAAK,CAACzF,MAAM;MACvB;IACJ;IACA;IACA,OAAO0F,SAAS;EACpB,CAAC;AACL;AACA,SAASC,cAAc,CAACb,QAAQ,EAAEc,MAAM,EAAEC,MAAM,EAAE;EAC9C,IAAIX,SAAS,GAAG1C,SAAS;EACzB,QAAQoD,MAAM;IACV,KAAK,gBAAgB;MACjB;MACA;MACA;MACA;MACA,OAAO,UAAUR,OAAO,EAAE;QACtB,MAAMtD,MAAM,GAAGsD,OAAO,CAACrC,GAAG,CAAEwC,CAAC,IAAKA,CAAC,CAACvF,MAAM,CAAC;QAC3C;QACA,IAAI8F,WAAW,GAAGjE,MAAM,CAACuD,OAAO,CAACrC,GAAG,CAAEwC,CAAC,IAAKA,CAAC,CAACvF,MAAM,CAAC,EAAE,CAAC,CAAC;QACzD,IAAI8F,WAAW,IAAI,IAAI,EAAE;UACrB,OAAOJ,SAAS;QACpB;QACAI,WAAW,GAAG3D,IAAI,CAAC4D,IAAI,CAACD,WAAW,CAAC;QACpC;QACA,IAAIhE,MAAM,CAACkE,OAAO,CAACF,WAAW,GAAG,CAAC,CAAC,IAAI,CAAC,EAAE;UACtCA,WAAW,EAAE;QACjB;QACA;QACA,IAAIA,WAAW,IAAIhB,QAAQ,CAACmB,mBAAmB,EAAE;UAC7CnB,QAAQ,CAACmB,mBAAmB,GAAGH,WAAW;QAC9C;QACA,OAAOhB,QAAQ,CAACmB,mBAAmB;MACvC,CAAC;IACL,KAAK,aAAa;MACd;MACA;MACA;MACA,OAAO,UAAUb,OAAO,EAAE;QACtB,MAAMtD,MAAM,GAAGsD,OAAO,CAACrC,GAAG,CAAEwC,CAAC,IAAKA,CAAC,CAACvF,MAAM,CAAC;QAC3C8B,MAAM,CAACG,IAAI,EAAE;QACb,OAAOH,MAAM,CAACK,IAAI,CAACC,KAAK,CAACN,MAAM,CAACP,MAAM,GAAG,CAAC,CAAC,CAAC;MAChD,CAAC;IACL,KAAK,eAAe;MAChB;MACA;MACA,OAAO,UAAU6D,OAAO,EAAE;QACtB,OAAOvD,MAAM,CAACuD,OAAO,CAACrC,GAAG,CAAEwC,CAAC,IAAKA,CAAC,CAACvF,MAAM,CAAC,CAAC;MAC/C,CAAC;IACL;IACA,KAAK,YAAY;IACjB,KAAK,qBAAqB;IAC1B,KAAK,SAAS;IACd,KAAK,cAAc;IACnB,KAAK,MAAM;IACX,KAAK,aAAa;IAClB,KAAK,SAAS;MACV;IACJ;IACA,KAAK,gBAAgB;IACrB,KAAK,uBAAuB;MACxBkF,SAAS,GAAG,UAAUgB,EAAE,EAAE;QACtB,IAAIA,EAAE,IAAI,IAAI,EAAE;UACZ,OAAO,IAAI;QACf;QACAA,EAAE,GAAGzF,WAAW,CAACyF,EAAE,CAAC;QACpBA,EAAE,CAACC,aAAa,GAAG,CAAC,CAAC;QACrB,OAAO3D,SAAS,CAAC0D,EAAE,CAAC;MACxB,CAAC;MACD;IACJ;IACA,KAAK,UAAU;MACX;MACA,IAAIL,MAAM,CAACO,mBAAmB,EAAE;QAC5BlB,SAAS,GAAG,UAAUmB,KAAK,EAAE;UACzB,IAAIA,KAAK,IAAI,IAAI,EAAE;YACf,OAAO,IAAI;UACf;UACAA,KAAK,GAAG5F,WAAW,CAAC4F,KAAK,CAAC;UAC1BA,KAAK,CAACC,YAAY,GAAGD,KAAK,CAACC,YAAY,CAACvD,GAAG,CAAEmD,EAAE,IAAK;YAChDA,EAAE,GAAGzF,WAAW,CAACyF,EAAE,CAAC;YACpBA,EAAE,CAACC,aAAa,GAAG,CAAC,CAAC;YACrB,OAAOD,EAAE;UACb,CAAC,CAAC;UACF,OAAO1D,SAAS,CAAC6D,KAAK,CAAC;QAC3B,CAAC;MACL,CAAC,MACI;QACDnB,SAAS,GAAG,UAAUmB,KAAK,EAAE;UACzB,IAAIA,KAAK,IAAI,IAAI,EAAE;YACf,OAAO,IAAI;UACf;UACA,OAAO7D,SAAS,CAAC6D,KAAK,CAAC;QAC3B,CAAC;MACL;MACA;IACJ;MACI,MAAM,IAAIhD,KAAK,CAAC,kBAAkB,GAAGuC,MAAM,CAAC;EAAC;EAErD;EACA;EACA,OAAOX,eAAe,CAACC,SAAS,EAAEJ,QAAQ,CAACK,MAAM,CAAC;AACtD;AACA;AACA;AACA,SAASoB,WAAW,CAAC7B,MAAM,EAAEoB,WAAW,EAAE;EACtC,OAAO7G,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;IAChD,MAAM6F,QAAQ,GAAIJ,MAAM,CAACI,QAAS;IAClC,IAAKA,QAAQ,CAACgB,WAAW,IAAI,IAAI,IAAIhB,QAAQ,CAACgB,WAAW,IAAIA,WAAW,IAAKA,WAAW,KAAK,CAAC,CAAC,EAAE;MAC7F,OAAOhB,QAAQ;IACnB;IACA,OAAOnE,IAAI,CAAC,MAAM;MACd,OAAO,IAAIlB,OAAO,CAAC,CAACD,OAAO,EAAEE,MAAM,KAAK;QACpCmE,UAAU,CAAC,YAAY;UACnB;UACA,IAAIiB,QAAQ,CAACgB,WAAW,IAAIA,WAAW,EAAE;YACrC,OAAOtG,OAAO,CAACsF,QAAQ,CAAC;UAC5B;UACA;UACA,IAAIJ,MAAM,CAAC8B,SAAS,EAAE;YAClB,OAAOhH,OAAO,CAAC,IAAI,CAAC;UACxB;UACA;UACA,OAAOA,OAAO,CAACkG,SAAS,CAAC;QAC7B,CAAC,EAAE,CAAC,CAAC;MACT,CAAC,CAAC;IACN,CAAC,EAAE;MAAEe,QAAQ,EAAE3B;IAAS,CAAC,CAAC;EAC9B,CAAC,CAAC;AACN;AACA,SAAS4B,SAAS,CAAChC,MAAM,EAAEiC,kBAAkB,EAAEf,MAAM,EAAEC,MAAM,EAAE;EAC3D,OAAO5G,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;IAChD,IAAI6F,QAAQ,GAAGJ,MAAM,CAACI,QAAQ;IAC9B,QAAQc,MAAM;MACV,KAAK,gBAAgB;MACrB,KAAK,aAAa;QACd,OAAOd,QAAQ,CAACc,MAAM,CAAC,EAAE;MAC7B,KAAK,eAAe;QAChB,IAAId,QAAQ,CAAC8B,aAAa,EAAE;UACxB,OAAO9B,QAAQ,CAAC8B,aAAa,EAAE;QACnC;QACA;MACJ,KAAK,YAAY;MACjB,KAAK,qBAAqB;MAC1B,KAAK,SAAS;QACV,IAAIf,MAAM,CAACgB,QAAQ,IAAIvG,WAAW,CAACuF,MAAM,CAACgB,QAAQ,CAAC,EAAE;UACjD/B,QAAQ,GAAG,MAAMyB,WAAW,CAAC7B,MAAM,EAAEiC,kBAAkB,CAAC;QAC5D;QACA,OAAO7B,QAAQ,CAACc,MAAM,CAAC,CAACC,MAAM,CAACiB,OAAO,EAAEjB,MAAM,CAACgB,QAAQ,IAAI,QAAQ,CAAC;MACxE,KAAK,cAAc;QACf,IAAIhB,MAAM,CAACgB,QAAQ,IAAIvG,WAAW,CAACuF,MAAM,CAACgB,QAAQ,CAAC,EAAE;UACjD/B,QAAQ,GAAG,MAAMyB,WAAW,CAAC7B,MAAM,EAAEiC,kBAAkB,CAAC;QAC5D;QACA,OAAO7B,QAAQ,CAACiC,YAAY,CAAClB,MAAM,CAACiB,OAAO,EAAEjB,MAAM,CAACmB,QAAQ,EAAEnB,MAAM,CAACgB,QAAQ,IAAI,QAAQ,CAAC;MAC9F,KAAK,UAAU;QACX,IAAIhB,MAAM,CAACgB,QAAQ,IAAIvG,WAAW,CAACuF,MAAM,CAACgB,QAAQ,CAAC,EAAE;UACjD/B,QAAQ,GAAG,MAAMyB,WAAW,CAAC7B,MAAM,EAAEiC,kBAAkB,CAAC;QAC5D;QACA,OAAO7B,QAAQ,CAAEe,MAAM,CAACO,mBAAmB,GAAG,0BAA0B,GAAG,UAAU,CAAE,CAACP,MAAM,CAACgB,QAAQ,IAAIhB,MAAM,CAACoB,SAAS,CAAC;MAChI,KAAK,MAAM;MACX,KAAK,aAAa;QACd,IAAIpB,MAAM,CAACgB,QAAQ,IAAIvG,WAAW,CAACuF,MAAM,CAACgB,QAAQ,CAAC,EAAE;UACjD/B,QAAQ,GAAG,MAAMyB,WAAW,CAAC7B,MAAM,EAAEiC,kBAAkB,CAAC;QAC5D;QACA,IAAIf,MAAM,KAAK,MAAM,IAAIC,MAAM,CAACgB,QAAQ,EAAE;UACtC,OAAO/B,QAAQ,CAACc,MAAM,CAAC,CAACC,MAAM,CAACqB,WAAW,EAAErB,MAAM,CAACgB,QAAQ,CAAC;QAChE;QACA,OAAO/B,QAAQ,CAACc,MAAM,CAAC,CAACC,MAAM,CAACqB,WAAW,CAAC;MAC/C,KAAK,gBAAgB;MACrB,KAAK,uBAAuB;QACxB,OAAOpC,QAAQ,CAACc,MAAM,CAAC,CAACC,MAAM,CAACsB,eAAe,CAAC;MACnD,KAAK,SAAS;QAAE;UACZ,IAAIC,MAAM,GAAGvB,MAAM,CAACuB,MAAM;UAC1B,IAAKA,MAAM,CAACC,SAAS,IAAI/G,WAAW,CAAC8G,MAAM,CAACC,SAAS,CAAC,IAAMD,MAAM,CAACE,OAAO,IAAIhH,WAAW,CAAC8G,MAAM,CAACE,OAAO,CAAE,EAAE;YACxGxC,QAAQ,GAAG,MAAMyB,WAAW,CAAC7B,MAAM,EAAEiC,kBAAkB,CAAC;UAC5D;UACA,OAAO7B,QAAQ,CAACyC,OAAO,CAACH,MAAM,CAAC;QACnC;IAAC;IAEL,OAAOpG,MAAM,CAACwG,UAAU,CAAC,sBAAsB,EAAE1G,MAAM,CAACoD,MAAM,CAACuD,aAAa,EAAE;MAC1E7B,MAAM,EAAEA,MAAM;MACdC,MAAM,EAAEA;IACZ,CAAC,CAAC;EACN,CAAC,CAAC;AACN;AACA,OAAO,MAAM6B,gBAAgB,SAAS9G,YAAY,CAAC;EAC/C+G,WAAW,CAACC,SAAS,EAAEzC,MAAM,EAAE;IAC3B,IAAIyC,SAAS,CAACrG,MAAM,KAAK,CAAC,EAAE;MACxBP,MAAM,CAACY,kBAAkB,CAAC,mBAAmB,EAAE,WAAW,EAAEgG,SAAS,CAAC;IAC1E;IACA,MAAMC,eAAe,GAAGD,SAAS,CAAC7E,GAAG,CAAC,CAAC+E,gBAAgB,EAAEC,KAAK,KAAK;MAC/D,IAAI3H,QAAQ,CAAC4H,UAAU,CAACF,gBAAgB,CAAC,EAAE;QACvC,MAAMG,YAAY,GAAGpH,mBAAmB,CAACiH,gBAAgB,CAAC,GAAG,IAAI,GAAG,GAAG;QACvE,MAAMI,QAAQ,GAAG,CAAC;QAClB,OAAOjF,MAAM,CAACkF,MAAM,CAAC;UAAErD,QAAQ,EAAEgD,gBAAgB;UAAEnD,MAAM,EAAE,CAAC;UAAEsD,YAAY;UAAEC;QAAS,CAAC,CAAC;MAC3F;MACA,MAAMxD,MAAM,GAAGjE,WAAW,CAACqH,gBAAgB,CAAC;MAC5C,IAAIpD,MAAM,CAACwD,QAAQ,IAAI,IAAI,EAAE;QACzBxD,MAAM,CAACwD,QAAQ,GAAG,CAAC;MACvB;MACA,IAAIxD,MAAM,CAACuD,YAAY,IAAI,IAAI,EAAE;QAC7BvD,MAAM,CAACuD,YAAY,GAAGpH,mBAAmB,CAACiH,gBAAgB,CAAC,GAAG,IAAI,GAAG,GAAG;MAC5E;MACA,IAAIpD,MAAM,CAACC,MAAM,IAAI,IAAI,EAAE;QACvBD,MAAM,CAACC,MAAM,GAAG,CAAC;MACrB;MACA,MAAMA,MAAM,GAAGD,MAAM,CAACC,MAAM;MAC5B,IAAIA,MAAM,GAAG,CAAC,IAAIA,MAAM,GAAG,GAAG,IAAIA,MAAM,GAAG,CAAC,EAAE;QAC1C3D,MAAM,CAACY,kBAAkB,CAAC,6CAA6C,EAAG,aAAYmG,KAAM,UAAS,EAAEpD,MAAM,CAAC;MAClH;MACA,OAAO1B,MAAM,CAACkF,MAAM,CAACzD,MAAM,CAAC;IAChC,CAAC,CAAC;IACF,MAAM0D,KAAK,GAAGP,eAAe,CAACQ,MAAM,CAAC,CAACC,KAAK,EAAE/C,CAAC,KAAM+C,KAAK,GAAG/C,CAAC,CAACZ,MAAO,EAAE,CAAC,CAAC;IACzE,IAAIQ,MAAM,IAAI,IAAI,EAAE;MAChBA,MAAM,GAAGiD,KAAK,GAAG,CAAC;IACtB,CAAC,MACI,IAAIjD,MAAM,GAAGiD,KAAK,EAAE;MACrBpH,MAAM,CAACY,kBAAkB,CAAC,mDAAmD,EAAE,QAAQ,EAAEuD,MAAM,CAAC;IACpG;IACA;IACA,IAAIoD,cAAc,GAAGnH,aAAa,CAACyG,eAAe,CAAC9E,GAAG,CAAEwC,CAAC,IAAMA,CAAC,CAACT,QAAQ,CAAEtD,OAAO,CAAC,CAAC;IACpF;IACA,IAAI+G,cAAc,IAAI,IAAI,EAAE;MACxBA,cAAc,GAAG,IAAI9I,OAAO,CAAC,CAACD,OAAO,EAAEE,MAAM,KAAK;QAC9CmE,UAAU,CAAC,MAAM;UACb,IAAI,CAAC2E,aAAa,EAAE,CAACtI,IAAI,CAACV,OAAO,EAAEE,MAAM,CAAC;QAC9C,CAAC,EAAE,CAAC,CAAC;MACT,CAAC,CAAC;IACN;IACA,KAAK,CAAC6I,cAAc,CAAC;IACrB;IACA/H,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAEyC,MAAM,CAACkF,MAAM,CAACN,eAAe,CAAC,CAAC;IACvErH,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE2E,MAAM,CAAC;IACtC,IAAI,CAACc,mBAAmB,GAAG,CAAC,CAAC;EACjC;EACAuC,aAAa,GAAG;IACZ,OAAOvJ,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;MAChD,MAAMoC,QAAQ,GAAG,MAAM5B,OAAO,CAACgJ,GAAG,CAAC,IAAI,CAACZ,eAAe,CAAC9E,GAAG,CAAEwC,CAAC,IAAKA,CAAC,CAACT,QAAQ,CAAC4D,UAAU,EAAE,CAAC,CAAC;MAC5F,OAAOtH,aAAa,CAACC,QAAQ,CAAC;IAClC,CAAC,CAAC;EACN;EACAsH,OAAO,CAAC/C,MAAM,EAAEC,MAAM,EAAE;IACpB,OAAO5G,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;MAChD;MACA,IAAI2G,MAAM,KAAK,iBAAiB,EAAE;QAC9B,MAAMgD,OAAO,GAAG,MAAMnJ,OAAO,CAACgJ,GAAG,CAAC,IAAI,CAACZ,eAAe,CAAC9E,GAAG,CAAEwC,CAAC,IAAK;UAC9D,OAAOA,CAAC,CAACT,QAAQ,CAAC+D,eAAe,CAAChD,MAAM,CAACiD,iBAAiB,CAAC,CAAC5I,IAAI,CAAEF,MAAM,IAAK;YACzE,OAAOA,MAAM,CAAC+I,IAAI;UACtB,CAAC,EAAG/D,KAAK,IAAK;YACV,OAAOA,KAAK;UAChB,CAAC,CAAC;QACN,CAAC,CAAC,CAAC;QACH;QACA,KAAK,IAAI1D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsH,OAAO,CAACrH,MAAM,EAAED,CAAC,EAAE,EAAE;UACrC,MAAMtB,MAAM,GAAG4I,OAAO,CAACtH,CAAC,CAAC;UACzB,IAAI,OAAQtB,MAAO,KAAK,QAAQ,EAAE;YAC9B,OAAOA,MAAM;UACjB;QACJ;QACA;QACA,MAAM4I,OAAO,CAAC,CAAC,CAAC;MACpB;MACA;MACA;MACA,IAAI,IAAI,CAAC3C,mBAAmB,KAAK,CAAC,CAAC,IAAIL,MAAM,KAAK,gBAAgB,EAAE;QAChE,MAAM,IAAI,CAACoD,cAAc,EAAE;MAC/B;MACA,MAAMC,WAAW,GAAGtD,cAAc,CAAC,IAAI,EAAEC,MAAM,EAAEC,MAAM,CAAC;MACxD;MACA;MACA,MAAMT,OAAO,GAAG1E,QAAQ,CAAC,IAAI,CAACmH,eAAe,CAAC9E,GAAG,CAACtC,WAAW,CAAC,CAAC;MAC/D2E,OAAO,CAACnD,IAAI,CAAC,CAACI,CAAC,EAAEC,CAAC,KAAMD,CAAC,CAAC6F,QAAQ,GAAG5F,CAAC,CAAC4F,QAAS,CAAC;MACjD,MAAMvB,kBAAkB,GAAG,IAAI,CAACV,mBAAmB;MACnD,IAAI3E,CAAC,GAAG,CAAC;MACT,IAAI4H,KAAK,GAAG,IAAI;MAChB,OAAO,IAAI,EAAE;QACT,MAAMC,EAAE,GAAGlI,GAAG,EAAE;QAChB;QACA,IAAImI,cAAc,GAAGhE,OAAO,CAACgC,MAAM,CAAE7B,CAAC,IAAMA,CAAC,CAAC8D,MAAM,IAAMF,EAAE,GAAG5D,CAAC,CAACR,KAAK,GAAIQ,CAAC,CAAC0C,YAAc,CAAC,CACtFI,MAAM,CAAC,CAACC,KAAK,EAAE/C,CAAC,KAAM+C,KAAK,GAAG/C,CAAC,CAACZ,MAAO,EAAE,CAAC,CAAC;QAChD;QACA,OAAOyE,cAAc,GAAG,IAAI,CAACjE,MAAM,IAAI7D,CAAC,GAAG8D,OAAO,CAAC7D,MAAM,EAAE;UACvD,MAAMmD,MAAM,GAAGU,OAAO,CAAC9D,CAAC,EAAE,CAAC;UAC3B,MAAMgI,GAAG,GAAGhG,OAAO,EAAE;UACrBoB,MAAM,CAACK,KAAK,GAAG9D,GAAG,EAAE;UACpByD,MAAM,CAAC6E,OAAO,GAAGhG,KAAK,CAACmB,MAAM,CAACuD,YAAY,CAAC;UAC3CvD,MAAM,CAAC6E,OAAO,CAACzF,IAAI,CAAC,MAAM;YAAEY,MAAM,CAAC6E,OAAO,GAAG,IAAI;UAAE,CAAC,CAAC;UACrD7E,MAAM,CAAC2E,MAAM,GAAG3C,SAAS,CAAChC,MAAM,EAAEiC,kBAAkB,EAAEf,MAAM,EAAEC,MAAM,CAAC,CAAC3F,IAAI,CAAEF,MAAM,IAAK;YACnF0E,MAAM,CAACzE,IAAI,GAAG,IAAI;YAClByE,MAAM,CAAC1E,MAAM,GAAGA,MAAM;YACtB,IAAI,IAAI,CAACwJ,aAAa,CAAC,OAAO,CAAC,EAAE;cAC7B,IAAI,CAACC,IAAI,CAAC,OAAO,EAAE;gBACfC,MAAM,EAAE,SAAS;gBACjBJ,GAAG,EAAEA,GAAG;gBACRK,OAAO,EAAElF,iBAAiB,CAACC,MAAM,EAAEzD,GAAG,EAAE,CAAC;gBACzC2I,OAAO,EAAE;kBAAEhE,MAAM,EAAEA,MAAM;kBAAEC,MAAM,EAAEtF,QAAQ,CAACsF,MAAM;gBAAE,CAAC;gBACrDf,QAAQ,EAAE;cACd,CAAC,CAAC;YACN;UACJ,CAAC,EAAGE,KAAK,IAAK;YACVN,MAAM,CAACzE,IAAI,GAAG,IAAI;YAClByE,MAAM,CAACM,KAAK,GAAGA,KAAK;YACpB,IAAI,IAAI,CAACwE,aAAa,CAAC,OAAO,CAAC,EAAE;cAC7B,IAAI,CAACC,IAAI,CAAC,OAAO,EAAE;gBACfC,MAAM,EAAE,SAAS;gBACjBJ,GAAG,EAAEA,GAAG;gBACRK,OAAO,EAAElF,iBAAiB,CAACC,MAAM,EAAEzD,GAAG,EAAE,CAAC;gBACzC2I,OAAO,EAAE;kBAAEhE,MAAM,EAAEA,MAAM;kBAAEC,MAAM,EAAEtF,QAAQ,CAACsF,MAAM;gBAAE,CAAC;gBACrDf,QAAQ,EAAE;cACd,CAAC,CAAC;YACN;UACJ,CAAC,CAAC;UACF,IAAI,IAAI,CAAC0E,aAAa,CAAC,OAAO,CAAC,EAAE;YAC7B,IAAI,CAACC,IAAI,CAAC,OAAO,EAAE;cACfC,MAAM,EAAE,SAAS;cACjBJ,GAAG,EAAEA,GAAG;cACRK,OAAO,EAAElF,iBAAiB,CAACC,MAAM,EAAE,IAAI,CAAC;cACxCkF,OAAO,EAAE;gBAAEhE,MAAM,EAAEA,MAAM;gBAAEC,MAAM,EAAEtF,QAAQ,CAACsF,MAAM;cAAE,CAAC;cACrDf,QAAQ,EAAE;YACd,CAAC,CAAC;UACN;UACAsE,cAAc,IAAI1E,MAAM,CAACC,MAAM;QACnC;QACA;QACA,MAAMkF,OAAO,GAAG,EAAE;QAClBzE,OAAO,CAACE,OAAO,CAAEC,CAAC,IAAK;UACnB,IAAIA,CAAC,CAACtF,IAAI,IAAI,CAACsF,CAAC,CAAC8D,MAAM,EAAE;YACrB;UACJ;UACAQ,OAAO,CAACC,IAAI,CAACvE,CAAC,CAAC8D,MAAM,CAAC;UACtB,IAAI9D,CAAC,CAACgE,OAAO,EAAE;YACXM,OAAO,CAACC,IAAI,CAACvE,CAAC,CAACgE,OAAO,CAACvF,UAAU,EAAE,CAAC;UACxC;QACJ,CAAC,CAAC;QACF,IAAI6F,OAAO,CAACtI,MAAM,EAAE;UAChB,MAAM9B,OAAO,CAACsK,IAAI,CAACF,OAAO,CAAC;QAC/B;QACA;QACA;QACA,MAAMjB,OAAO,GAAGxD,OAAO,CAACgC,MAAM,CAAE7B,CAAC,IAAMA,CAAC,CAACtF,IAAI,IAAIsF,CAAC,CAACP,KAAK,IAAI,IAAK,CAAC;QAClE,IAAI4D,OAAO,CAACrH,MAAM,IAAI,IAAI,CAAC4D,MAAM,EAAE;UAC/B,MAAMnF,MAAM,GAAGiJ,WAAW,CAACL,OAAO,CAAC;UACnC,IAAI5I,MAAM,KAAK0F,SAAS,EAAE;YACtB;YACAN,OAAO,CAACE,OAAO,CAACC,CAAC,IAAI;cACjB,IAAIA,CAAC,CAACgE,OAAO,EAAE;gBACXhE,CAAC,CAACgE,OAAO,CAAC9F,MAAM,EAAE;cACtB;cACA8B,CAAC,CAACiB,SAAS,GAAG,IAAI;YACtB,CAAC,CAAC;YACF,OAAOxG,MAAM;UACjB;UACA,IAAI,CAACkJ,KAAK,EAAE;YACR,MAAM3F,KAAK,CAAC,GAAG,CAAC,CAACS,UAAU,EAAE;UACjC;UACAkF,KAAK,GAAG,KAAK;QACjB;QACA;QACA,MAAMhF,MAAM,GAAGkB,OAAO,CAACiD,MAAM,CAAC,CAACC,KAAK,EAAE/C,CAAC,KAAK;UACxC,IAAI,CAACA,CAAC,CAACtF,IAAI,IAAIsF,CAAC,CAACP,KAAK,IAAI,IAAI,EAAE;YAC5B,OAAOsD,KAAK;UAChB;UACA,MAAM0B,IAAI,GAAIzE,CAAC,CAACP,KAAK,CAAEgF,IAAI;UAC3B,IAAI/F,aAAa,CAAC+B,OAAO,CAACgE,IAAI,CAAC,IAAI,CAAC,EAAE;YAClC,IAAI,CAAC1B,KAAK,CAAC0B,IAAI,CAAC,EAAE;cACd1B,KAAK,CAAC0B,IAAI,CAAC,GAAG;gBAAEhF,KAAK,EAAEO,CAAC,CAACP,KAAK;gBAAEL,MAAM,EAAE;cAAE,CAAC;YAC/C;YACA2D,KAAK,CAAC0B,IAAI,CAAC,CAACrF,MAAM,IAAIY,CAAC,CAACZ,MAAM;UAClC;UACA,OAAO2D,KAAK;QAChB,CAAC,EAAG,CAAC,CAAC,CAAE;QACRrF,MAAM,CAACD,IAAI,CAACkB,MAAM,CAAC,CAACoB,OAAO,CAAE2E,SAAS,IAAK;UACvC,MAAM5E,KAAK,GAAGnB,MAAM,CAAC+F,SAAS,CAAC;UAC/B,IAAI5E,KAAK,CAACV,MAAM,GAAG,IAAI,CAACQ,MAAM,EAAE;YAC5B;UACJ;UACA;UACAC,OAAO,CAACE,OAAO,CAACC,CAAC,IAAI;YACjB,IAAIA,CAAC,CAACgE,OAAO,EAAE;cACXhE,CAAC,CAACgE,OAAO,CAAC9F,MAAM,EAAE;YACtB;YACA8B,CAAC,CAACiB,SAAS,GAAG,IAAI;UACtB,CAAC,CAAC;UACF,MAAM1G,CAAC,GAAIuF,KAAK,CAACL,KAAM;UACvB,MAAMkF,KAAK,GAAG,CAAC,CAAC;UAChB1F,iBAAiB,CAACc,OAAO,CAAE7D,IAAI,IAAK;YAChC,IAAI3B,CAAC,CAAC2B,IAAI,CAAC,IAAI,IAAI,EAAE;cACjB;YACJ;YACAyI,KAAK,CAACzI,IAAI,CAAC,GAAG3B,CAAC,CAAC2B,IAAI,CAAC;UACzB,CAAC,CAAC;UACFT,MAAM,CAACwG,UAAU,CAAC1H,CAAC,CAACqK,MAAM,IAAIrK,CAAC,CAACsK,OAAO,EAAEH,SAAS,EAAEC,KAAK,CAAC;QAC9D,CAAC,CAAC;QACF;QACA,IAAI9E,OAAO,CAACgC,MAAM,CAAE7B,CAAC,IAAK,CAACA,CAAC,CAACtF,IAAI,CAAC,CAACsB,MAAM,KAAK,CAAC,EAAE;UAC7C;QACJ;MACJ;MACA;MACA6D,OAAO,CAACE,OAAO,CAACC,CAAC,IAAI;QACjB,IAAIA,CAAC,CAACgE,OAAO,EAAE;UACXhE,CAAC,CAACgE,OAAO,CAAC9F,MAAM,EAAE;QACtB;QACA8B,CAAC,CAACiB,SAAS,GAAG,IAAI;MACtB,CAAC,CAAC;MACF,OAAOxF,MAAM,CAACwG,UAAU,CAAC,uBAAuB,EAAE1G,MAAM,CAACoD,MAAM,CAACmG,YAAY,EAAE;QAC1EzE,MAAM,EAAEA,MAAM;QACdC,MAAM,EAAEA,MAAM;QACd;QACA;QACA+C,OAAO,EAAExD,OAAO,CAACrC,GAAG,CAAEwC,CAAC,IAAKd,iBAAiB,CAACc,CAAC,CAAC,CAAC;QACjDT,QAAQ,EAAE;MACd,CAAC,CAAC;IACN,CAAC,CAAC;EACN;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}