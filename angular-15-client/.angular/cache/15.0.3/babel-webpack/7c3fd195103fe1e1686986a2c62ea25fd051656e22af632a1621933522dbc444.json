{"ast":null,"code":"\"use strict\";\n\nimport { EC } from \"./elliptic\";\nimport { arrayify, hexDataLength, hexlify, hexZeroPad, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nlet _curve = null;\nfunction getCurve() {\n  if (!_curve) {\n    _curve = new EC(\"secp256k1\");\n  }\n  return _curve;\n}\nexport class SigningKey {\n  constructor(privateKey) {\n    defineReadOnly(this, \"curve\", \"secp256k1\");\n    defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n    if (hexDataLength(this.privateKey) !== 32) {\n      logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n    }\n    const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n    defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n    defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n    defineReadOnly(this, \"_isSigningKey\", true);\n  }\n  _addPoint(other) {\n    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));\n    const p1 = getCurve().keyFromPublic(arrayify(other));\n    return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n  }\n  signDigest(digest) {\n    const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n    const digestBytes = arrayify(digest);\n    if (digestBytes.length !== 32) {\n      logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n    }\n    const signature = keyPair.sign(digestBytes, {\n      canonical: true\n    });\n    return splitSignature({\n      recoveryParam: signature.recoveryParam,\n      r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n      s: hexZeroPad(\"0x\" + signature.s.toString(16), 32)\n    });\n  }\n  computeSharedSecret(otherKey) {\n    const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n    return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n  }\n  static isSigningKey(value) {\n    return !!(value && value._isSigningKey);\n  }\n}\nexport function recoverPublicKey(digest, signature) {\n  const sig = splitSignature(signature);\n  const rs = {\n    r: arrayify(sig.r),\n    s: arrayify(sig.s)\n  };\n  return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nexport function computePublicKey(key, compressed) {\n  const bytes = arrayify(key);\n  if (bytes.length === 32) {\n    const signingKey = new SigningKey(bytes);\n    if (compressed) {\n      return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n    }\n    return signingKey.publicKey;\n  } else if (bytes.length === 33) {\n    if (compressed) {\n      return hexlify(bytes);\n    }\n    return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n  } else if (bytes.length === 65) {\n    if (!compressed) {\n      return hexlify(bytes);\n    }\n    return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n  }\n  return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}","map":{"version":3,"names":["EC","arrayify","hexDataLength","hexlify","hexZeroPad","splitSignature","defineReadOnly","Logger","version","logger","_curve","getCurve","SigningKey","constructor","privateKey","throwArgumentError","keyPair","keyFromPrivate","getPublic","_addPoint","other","p0","keyFromPublic","publicKey","p1","pub","add","encodeCompressed","signDigest","digest","digestBytes","length","signature","sign","canonical","recoveryParam","r","toString","s","computeSharedSecret","otherKey","otherKeyPair","computePublicKey","derive","isSigningKey","value","_isSigningKey","recoverPublicKey","sig","rs","recoverPubKey","encode","key","compressed","bytes","signingKey"],"sources":["F:/DDesktop/MEAN_BC/mean-stack-authentication-authorization-master/angular-15-client/node_modules/@ethersproject/signing-key/lib.esm/index.js"],"sourcesContent":["\"use strict\";\nimport { EC } from \"./elliptic\";\nimport { arrayify, hexDataLength, hexlify, hexZeroPad, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nlet _curve = null;\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\nexport class SigningKey {\n    constructor(privateKey) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n    _addPoint(other) {\n        const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 = getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n    signDigest(digest) {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        });\n    }\n    computeSharedSecret(otherKey) {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n    static isSigningKey(value) {\n        return !!(value && value._isSigningKey);\n    }\n}\nexport function recoverPublicKey(digest, signature) {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nexport function computePublicKey(key, compressed) {\n    const bytes = arrayify(key);\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n    }\n    else if (bytes.length === 33) {\n        if (compressed) {\n            return hexlify(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n    }\n    else if (bytes.length === 65) {\n        if (!compressed) {\n            return hexlify(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}