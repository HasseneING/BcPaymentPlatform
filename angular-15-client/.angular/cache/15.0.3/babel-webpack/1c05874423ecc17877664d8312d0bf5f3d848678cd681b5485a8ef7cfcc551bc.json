{"ast":null,"code":"import { _ as __awaiter, f as fromHex, t as toHex, n as noop, C as CustomNetworks, i as isAlchemyEvent, v as verifyAlchemyEventName, c as EthersEvent, e as getAlchemyEventTag, D as DEFAULT_ALCHEMY_API_KEY, A as ALCHEMY_EVENT_TYPES, h as ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE, j as AlchemySubscription, k as ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE, V as VERSION, E as EthersNetwork } from './index-596122b1.js';\nimport SturdyWebSocket from 'sturdy-websocket';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { getNetwork } from '@ethersproject/networks';\nimport { WebSocketProvider } from '@ethersproject/providers';\nimport { AlchemyProvider } from './alchemy-provider-afa3762a.js';\nimport './api/utils';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\nimport '@ethersproject/web';\n\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */\nclass WebsocketBackfiller {\n  constructor(provider) {\n    this.provider = provider;\n    // TODO: Use HTTP provider to do backfill.\n    this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  }\n  /**\r\n   * Runs backfill for `newHeads` events.\r\n   *\r\n   * @param isCancelled Whether the backfill request is cancelled.\r\n   * @param previousHeads Previous head requests that were sent.\r\n   * @param fromBlockNumber The block number to start backfilling from.\r\n   * @returns A list of `newHeads` events that were sent since the last backfill.\r\n   */\n  getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throwIfCancelled(isCancelled);\n      const toBlockNumber = yield this.getBlockNumber();\n      throwIfCancelled(isCancelled);\n      // If there are no previous heads to fetch, return new heads since\n      // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n      if (previousHeads.length === 0) {\n        return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\n      }\n      // If the last emitted event is too far back in the past, there's no need\n      // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n      // new heads.\n      const lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\n      const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n      if (lastSeenBlockNumber <= minBlockNumber) {\n        return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n      }\n      // To capture all `newHeads` events, return all head events from the last\n      // seen block number to current + any of the previous heads that were re-orged.\n      const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\n      throwIfCancelled(isCancelled);\n      const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\n      throwIfCancelled(isCancelled);\n      return [...reorgHeads, ...intermediateHeads];\n    });\n  }\n  /**\r\n   * Runs backfill for `logs` events.\r\n   *\r\n   * @param isCancelled Whether the backfill request is cancelled.\r\n   * @param filter The filter object that accompanies a logs subscription.\r\n   * @param previousLogs Previous log requests that were sent.\r\n   * @param fromBlockNumber The block number to start backfilling from.\r\n   */\n  getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throwIfCancelled(isCancelled);\n      const toBlockNumber = yield this.getBlockNumber();\n      throwIfCancelled(isCancelled);\n      // If there are no previous logs to fetch, return new logs since\n      // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n      if (previousLogs.length === 0) {\n        return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\n      }\n      // If the last emitted log is too far back in the past, there's no need\n      // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n      // worth of logs.\n      const lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\n      const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n      if (lastSeenBlockNumber < minBlockNumber) {\n        return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n      }\n      // Return all log events that have happened along with log events that have\n      // been removed due to a chain reorg.\n      const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\n      throwIfCancelled(isCancelled);\n      // All previous logs with a block number greater than the common ancestor\n      // were part of a re-org, so mark them as such.\n      const removedLogs = previousLogs.filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber).map(log => Object.assign(Object.assign({}, log), {\n        removed: true\n      }));\n      // If no common ancestor was found, start backfill from the oldest log's\n      // block number.\n      const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY ? fromHex(previousLogs[0].blockNumber) : commonAncestor.blockNumber;\n      let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\n      // De-dupe any logs that were already emitted.\n      addedLogs = addedLogs.filter(log => log && (fromHex(log.blockNumber) > commonAncestor.blockNumber || fromHex(log.logIndex) > commonAncestor.logIndex));\n      throwIfCancelled(isCancelled);\n      return [...removedLogs, ...addedLogs];\n    });\n  }\n  /**\r\n   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n   *\r\n   * @internal\r\n   */\n  setMaxBackfillBlock(newMax) {\n    this.maxBackfillBlocks = newMax;\n  }\n  /**\r\n   * Gets the current block number as a number.\r\n   *\r\n   * @private\r\n   */\n  getBlockNumber() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const blockNumberHex = yield this.provider.send('eth_blockNumber');\n      return fromHex(blockNumberHex);\n    });\n  }\n  /**\r\n   * Gets all `newHead` events in the provided range. Note that the returned\r\n   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n   * that were part of a re-org.\r\n   *\r\n   * @private\r\n   */\n  getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (fromBlockInclusive >= toBlockExclusive) {\n        return [];\n      }\n      const batchParts = [];\n      for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n        batchParts.push({\n          method: 'eth_getBlockByNumber',\n          params: [toHex(i), false]\n        });\n      }\n      // TODO: handle errors\n      const blockHeads = yield this.provider.sendBatch(batchParts);\n      return blockHeads.map(toNewHeadsEvent);\n    });\n  }\n  /**\r\n   * Returns all heads that were part of a reorg event.\r\n   *\r\n   * @private\r\n   */\n  getReorgHeads(isCancelled, previousHeads) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = [];\n      // Iterate from the most recent head backwards in order to find the first\n      // block that was part of a re-org.\n      for (let i = previousHeads.length - 1; i >= 0; i--) {\n        const oldEvent = previousHeads[i];\n        const blockHead = yield this.getBlockByNumber(fromHex(oldEvent.number));\n        throwIfCancelled(isCancelled);\n        // If the hashes match, then current head in the iteration was not re-orged.\n        if (oldEvent.hash === blockHead.hash) {\n          break;\n        }\n        result.push(toNewHeadsEvent(blockHead));\n      }\n      return result.reverse();\n    });\n  }\n  /**\r\n   * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n   * block information for the provided block number.\r\n   *\r\n   * @private\r\n   */\n  getBlockByNumber(blockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.provider.send('eth_getBlockByNumber', [toHex(blockNumber), false]);\n    });\n  }\n  /**\r\n   * Given a list of previous log events, finds the common block number from the\r\n   * logs that matches the block head.\r\n   *\r\n   * This can be used to identify which logs are part of a re-org.\r\n   *\r\n   * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n   *\r\n   * @private\r\n   */\n  getCommonAncestor(isCancelled, previousLogs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Iterate from the most recent head backwards in order to find the first\n      // block that was part of a re-org.\n      let blockHead = yield this.getBlockByNumber(fromHex(previousLogs[previousLogs.length - 1].blockNumber));\n      throwIfCancelled(isCancelled);\n      for (let i = previousLogs.length - 1; i >= 0; i--) {\n        const oldLog = previousLogs[i];\n        // Ensure that updated blocks are fetched every time the log's block number\n        // changes.\n        if (oldLog.blockNumber !== blockHead.number) {\n          blockHead = yield this.getBlockByNumber(fromHex(oldLog.blockNumber));\n        }\n        // Since logs are ordered in ascending order, the first log that matches\n        // the hash should be the largest logIndex.\n        if (oldLog.blockHash === blockHead.hash) {\n          return {\n            blockNumber: fromHex(oldLog.blockNumber),\n            logIndex: fromHex(oldLog.logIndex)\n          };\n        }\n      }\n      return {\n        blockNumber: Number.NEGATIVE_INFINITY,\n        logIndex: Number.NEGATIVE_INFINITY\n      };\n    });\n  }\n  /**\r\n   * Gets all `logs` events in the provided range. Note that the returned logs\r\n   * do not include removed logs.\r\n   *\r\n   * @private\r\n   */\n  getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (fromBlockInclusive >= toBlockExclusive) {\n        return [];\n      }\n      const rangeFilter = Object.assign(Object.assign({}, filter), {\n        fromBlock: toHex(fromBlockInclusive),\n        toBlock: toHex(toBlockExclusive - 1)\n      });\n      return this.provider.send('eth_getLogs', [rangeFilter]);\n    });\n  }\n}\nfunction toNewHeadsEvent(head) {\n  const result = Object.assign({}, head);\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\nfunction dedupeNewHeads(events) {\n  return dedupe(events, event => event.hash);\n}\nfunction dedupeLogs(events) {\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\n}\nfunction dedupe(items, getKey) {\n  const keysSeen = new Set();\n  const result = [];\n  items.forEach(item => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\nconst CANCELLED = new Error('Cancelled');\nfunction throwIfCancelled(isCancelled) {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */\nclass AlchemyWebSocketProvider extends WebSocketProvider {\n  /** @internal */\n  constructor(config, wsConstructor) {\n    var _a;\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');\n    const protocol = `alchemy-sdk-${VERSION}`;\n    // Use the provided config URL override if it exists, otherwise use the created one.\n    const ws = new SturdyWebSocket((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\n      wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\n    });\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(ws, ethersNetwork);\n    this._events = [];\n    // In the case of a WebSocket reconnection, all subscriptions are lost and we\n    // create new ones to replace them, but we want to create the illusion that\n    // the original subscriptions persist. Thus, maintain a mapping from the\n    // \"virtual\" subscription ids which are visible to the consumer to the\n    // \"physical\" subscription ids of the actual connections. This terminology is\n    // borrowed from virtual and physical memory, which has a similar mapping.\n    /** @internal */\n    this.virtualSubscriptionsById = new Map();\n    /** @internal */\n    this.virtualIdsByPhysicalId = new Map();\n    /**\r\n     * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n     * messages. To allow backfilling, track all messages that are emitted.\r\n     *\r\n     * This is a field arrow function in order to preserve `this` context when\r\n     * passing the method as an event listener.\r\n     *\r\n     * @internal\r\n     */\n    this.handleMessage = event => {\n      const message = JSON.parse(event.data);\n      if (!isSubscriptionEvent(message)) {\n        return;\n      }\n      const physicalId = message.params.subscription;\n      const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n      if (!virtualId) {\n        return;\n      }\n      const subscription = this.virtualSubscriptionsById.get(virtualId);\n      if (subscription.method !== 'eth_subscribe') {\n        return;\n      }\n      switch (subscription.params[0]) {\n        case 'newHeads':\n          {\n            const newHeadsSubscription = subscription;\n            const newHeadsMessage = message;\n            const {\n              isBackfilling,\n              backfillBuffer\n            } = newHeadsSubscription;\n            const {\n              result\n            } = newHeadsMessage.params;\n            if (isBackfilling) {\n              addToNewHeadsEventsBuffer(backfillBuffer, result);\n            } else if (physicalId !== virtualId) {\n              // In the case of a re-opened subscription, ethers will not emit the\n              // event, so the SDK has to.\n              this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n            } else {\n              // Ethers subscription mapping will emit the event, just store it.\n              this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n            }\n            break;\n          }\n        case 'logs':\n          {\n            const logsSubscription = subscription;\n            const logsMessage = message;\n            const {\n              isBackfilling,\n              backfillBuffer\n            } = logsSubscription;\n            const {\n              result\n            } = logsMessage.params;\n            if (isBackfilling) {\n              addToLogsEventsBuffer(backfillBuffer, result);\n            } else if (virtualId !== physicalId) {\n              this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n            } else {\n              this.rememberEvent(virtualId, result, getLogsBlockNumber);\n            }\n            break;\n          }\n        default:\n          if (physicalId !== virtualId) {\n            // In the case of a re-opened subscription, ethers will not emit the\n            // event, so the SDK has to.\n            const {\n              result\n            } = message.params;\n            this.emitEvent(virtualId, result);\n          }\n      }\n    };\n    /**\r\n     * When the websocket connection reopens:\r\n     *\r\n     * 1. Resubscribe to all existing subscriptions and start backfilling\r\n     * 2. Restart heart beat.\r\n     *\r\n     * This is a field arrow function in order to preserve `this` context when\r\n     * passing the method as an event listener.\r\n     *\r\n     * @internal\r\n     */\n    this.handleReopen = () => {\n      this.virtualIdsByPhysicalId.clear();\n      const {\n        cancel,\n        isCancelled\n      } = makeCancelToken();\n      this.cancelBackfill = cancel;\n      for (const subscription of this.virtualSubscriptionsById.values()) {\n        void (() => __awaiter(this, void 0, void 0, function* () {\n          try {\n            yield this.resubscribeAndBackfill(isCancelled, subscription);\n          } catch (error) {\n            if (!isCancelled()) {\n              console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\n            }\n          }\n        }))();\n      }\n      this.startHeartbeat();\n    };\n    /**\r\n     * Cancels the heartbeat and any pending backfills being performed. This is\r\n     * called when the websocket connection goes down or is disconnected.\r\n     *\r\n     * This is a field arrow function in order to preserve `this` context when\r\n     * passing the method as an event listener.\r\n     *\r\n     * @internal\r\n     */\n    this.stopHeartbeatAndBackfill = () => {\n      if (this.heartbeatIntervalId != null) {\n        clearInterval(this.heartbeatIntervalId);\n        this.heartbeatIntervalId = undefined;\n      }\n      this.cancelBackfill();\n    };\n    this.apiKey = apiKey;\n    // Start heartbeat and backfiller for the websocket connection.\n    this.backfiller = new WebsocketBackfiller(this);\n    this.addSocketListeners();\n    this.startHeartbeat();\n    this.cancelBackfill = noop;\n  }\n  /**\r\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n   *\r\n   * This override allows the SDK to set the provider's network to values not\r\n   * yet supported by ethers.js.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  static getNetwork(network) {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetwork(network);\n  }\n  /**\r\n   * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n   *\r\n   * @param eventName Event to subscribe to\r\n   * @param listener The listener function to call when the event is triggered.\r\n   * @override\r\n   * @public\r\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  on(eventName, listener) {\n    return this._addEventListener(eventName, listener, false);\n  }\n  /**\r\n   * Overridden implementation of ethers that includes Alchemy based\r\n   * subscriptions. Adds a listener to the triggered for only the next\r\n   * {@link eventName} event, after which it will be removed.\r\n   *\r\n   * @param eventName Event to subscribe to\r\n   * @param listener The listener function to call when the event is triggered.\r\n   * @override\r\n   * @public\r\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  once(eventName, listener) {\n    return this._addEventListener(eventName, listener, true);\n  }\n  /**\r\n   * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n   * listener is provided, all listeners for the event will be removed.\r\n   *\r\n   * @param eventName Event to unlisten to.\r\n   * @param listener The listener function to remove.\r\n   * @override\r\n   * @public\r\n   */\n  off(eventName, listener) {\n    if (isAlchemyEvent(eventName)) {\n      return this._off(eventName, listener);\n    } else {\n      return super.off(eventName, listener);\n    }\n  }\n  /**\r\n   * Remove all listeners for the provided {@link eventName} event. If no event\r\n   * is provided, all events and their listeners are removed.\r\n   *\r\n   * @param eventName The event to remove all listeners for.\r\n   * @override\r\n   * @public\r\n   */\n  removeAllListeners(eventName) {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._removeAllListeners(eventName);\n    } else {\n      return super.removeAllListeners(eventName);\n    }\n  }\n  /**\r\n   * Returns the number of listeners for the provided {@link eventName} event. If\r\n   * no event is provided, the total number of listeners for all events is returned.\r\n   *\r\n   * @param eventName The event to get the number of listeners for.\r\n   * @public\r\n   * @override\r\n   */\n  listenerCount(eventName) {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listenerCount(eventName);\n    } else {\n      return super.listenerCount(eventName);\n    }\n  }\n  /**\r\n   * Returns an array of listeners for the provided {@link eventName} event. If\r\n   * no event is provided, all listeners will be included.\r\n   *\r\n   * @param eventName The event to get the listeners for.\r\n   * @public\r\n   * @override\r\n   */\n  listeners(eventName) {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listeners(eventName);\n    } else {\n      return super.listeners(eventName);\n    }\n  }\n  /**\r\n   * Overrides the method in `BaseProvider` in order to properly format the\r\n   * Alchemy subscription events.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  _addEventListener(eventName, listener, once) {\n    if (isAlchemyEvent(eventName)) {\n      verifyAlchemyEventName(eventName);\n      const event = new EthersEvent(getAlchemyEventTag(eventName), listener, once);\n      this._events.push(event);\n      this._startEvent(event);\n      return this;\n    } else {\n      return super._addEventListener(eventName, listener, once);\n    }\n  }\n  /**\r\n   * Overrides the `_startEvent()` method in ethers.js's\r\n   * {@link WebSocketProvider} to include additional alchemy methods.\r\n   *\r\n   * @param event\r\n   * @override\r\n   * @internal\r\n   */\n  _startEvent(event) {\n    // Check if the event type is a custom Alchemy subscription.\n    const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\n    if (customLogicTypes.includes(event.type)) {\n      this.customStartEvent(event);\n    } else {\n      super._startEvent(event);\n    }\n  }\n  /**\r\n   * Overridden from ethers.js's {@link WebSocketProvider}\r\n   *\r\n   * Modified in order to add mappings for backfilling.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  _subscribe(tag, param, processFunc, event) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let subIdPromise = this._subIds[tag];\n      // BEGIN MODIFIED CODE\n      const startingBlockNumber = yield this.getBlockNumber();\n      // END MODIFIED CODE\n      if (subIdPromise == null) {\n        subIdPromise = Promise.all(param).then(param => {\n          return this.send('eth_subscribe', param);\n        });\n        this._subIds[tag] = subIdPromise;\n      }\n      const subId = yield subIdPromise;\n      // BEGIN MODIFIED CODE\n      const resolvedParams = yield Promise.all(param);\n      this.virtualSubscriptionsById.set(subId, {\n        event: event,\n        method: 'eth_subscribe',\n        params: resolvedParams,\n        startingBlockNumber,\n        virtualId: subId,\n        physicalId: subId,\n        sentEvents: [],\n        isBackfilling: false,\n        backfillBuffer: []\n      });\n      this.virtualIdsByPhysicalId.set(subId, subId);\n      // END MODIFIED CODE\n      this._subs[subId] = {\n        tag,\n        processFunc\n      };\n    });\n  }\n  /**\r\n   * DO NOT MODIFY.\r\n   *\r\n   * Original code copied over from ether.js's `BaseProvider`.\r\n   *\r\n   * This method is copied over directly in order to implement Alchemy's unique\r\n   * subscription types. The only difference is that this method calls\r\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n   * order to parse the Alchemy subscription event.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  emit(eventName, ...args) {\n    if (isAlchemyEvent(eventName)) {\n      let result = false;\n      const stopped = [];\n      // This line is the only modified line from the original method.\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        setTimeout(() => {\n          event.listener.apply(this, args);\n        }, 0);\n        result = true;\n        if (event.once) {\n          stopped.push(event);\n          return false;\n        }\n        return true;\n      });\n      stopped.forEach(event => {\n        this._stopEvent(event);\n      });\n      return result;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n  /** @internal */\n  sendBatch(parts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let nextId = 0;\n      const payload = parts.map(({\n        method,\n        params\n      }) => {\n        return {\n          method,\n          params,\n          jsonrpc: '2.0',\n          id: `alchemy-sdk:${nextId++}`\n        };\n      });\n      return this.sendBatchConcurrently(payload);\n    });\n  }\n  /** @override */\n  destroy() {\n    this.removeSocketListeners();\n    this.stopHeartbeatAndBackfill();\n    return super.destroy();\n  }\n  /**\r\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n   * current api key is the default key.\r\n   *\r\n   * @override\r\n   */\n  isCommunityResource() {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n  /**\r\n   * DO NOT MODIFY.\r\n   *\r\n   * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n   *\r\n   * This method is copied over directly in order to support Alchemy's\r\n   * subscription type by allowing the provider to properly stop Alchemy's\r\n   * subscription events.\r\n   *\r\n   * @internal\r\n   */\n  _stopEvent(event) {\n    let tag = event.tag;\n    // START MODIFIED CODE\n    if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\n      // There are remaining pending transaction listeners.\n      if (this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length) {\n        return;\n      }\n      // END MODIFIED CODE\n    } else if (event.type === 'tx') {\n      // There are remaining transaction event listeners\n      if (this._events.filter(e => e.type === 'tx').length) {\n        return;\n      }\n      tag = 'tx';\n    } else if (this.listenerCount(event.event)) {\n      // There are remaining event listeners\n      return;\n    }\n    const subId = this._subIds[tag];\n    if (!subId) {\n      return;\n    }\n    delete this._subIds[tag];\n    void subId.then(subId => {\n      if (!this._subs[subId]) {\n        return;\n      }\n      delete this._subs[subId];\n      void this.send('eth_unsubscribe', [subId]);\n    });\n  }\n  /** @internal */\n  addSocketListeners() {\n    this._websocket.addEventListener('message', this.handleMessage);\n    this._websocket.addEventListener('reopen', this.handleReopen);\n    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n  /** @internal */\n  removeSocketListeners() {\n    this._websocket.removeEventListener('message', this.handleMessage);\n    this._websocket.removeEventListener('reopen', this.handleReopen);\n    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n  /**\r\n   * Reopens the backfill based on\r\n   *\r\n   * @param isCancelled\r\n   * @param subscription\r\n   * @internal\r\n   */\n  resubscribeAndBackfill(isCancelled, subscription) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        virtualId,\n        method,\n        params,\n        sentEvents,\n        backfillBuffer,\n        startingBlockNumber\n      } = subscription;\n      subscription.isBackfilling = true;\n      backfillBuffer.length = 0;\n      try {\n        const physicalId = yield this.send(method, params);\n        throwIfCancelled(isCancelled);\n        subscription.physicalId = physicalId;\n        this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n        switch (params[0]) {\n          case 'newHeads':\n            {\n              const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\n              throwIfCancelled(isCancelled);\n              const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n              events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n              break;\n            }\n          case 'logs':\n            {\n              const filter = params[1] || {};\n              const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\n              throwIfCancelled(isCancelled);\n              const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n              events.forEach(event => this.emitLogsEvent(virtualId, event));\n              break;\n            }\n          default:\n            break;\n        }\n      } finally {\n        subscription.isBackfilling = false;\n        backfillBuffer.length = 0;\n      }\n    });\n  }\n  /** @internal */\n  emitNewHeadsEvent(virtualId, result) {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n  /** @internal */\n  emitLogsEvent(virtualId, result) {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n  /**\r\n   * Emits an event to consumers, but also remembers it in its subscriptions's\r\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n   * and needs to be reconnected.\r\n   *\r\n   * @internal\r\n   */\n  emitAndRememberEvent(virtualId, result, getBlockNumber) {\n    this.rememberEvent(virtualId, result, getBlockNumber);\n    this.emitEvent(virtualId, result);\n  }\n  emitEvent(virtualId, result) {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    this.emitGenericEvent(subscription, result);\n  }\n  /** @internal */\n  rememberEvent(virtualId, result, getBlockNumber) {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\n  }\n  /** @internal */\n  emitGenericEvent(subscription, result) {\n    const emitFunction = this.emitProcessFn(subscription.event);\n    emitFunction(result);\n  }\n  /**\r\n   * Starts a heartbeat that pings the websocket server periodically to ensure\r\n   * that the connection stays open.\r\n   *\r\n   * @internal\r\n   */\n  startHeartbeat() {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n      } catch (_a) {\n        this._websocket.reconnect();\n      }\n    }), HEARTBEAT_INTERVAL);\n  }\n  /**\r\n   * This method sends the batch concurrently as individual requests rather than\r\n   * as a batch, which was the original implementation. The original batch logic\r\n   * is preserved in this implementation in order for faster porting.\r\n   *\r\n   * @param payload\r\n   * @internal\r\n   */\n  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n  // TODO(errors): Use allSettled() once we have more error handling.\n  sendBatchConcurrently(payload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return Promise.all(payload.map(req => this.send(req.method, req.params)));\n    });\n  }\n  /** @internal */\n  customStartEvent(event) {\n    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      const {\n        fromAddress,\n        toAddress,\n        hashesOnly\n      } = event;\n      void this._subscribe(event.tag, [AlchemySubscription.PENDING_TRANSACTIONS, {\n        fromAddress,\n        toAddress,\n        hashesOnly\n      }], this.emitProcessFn(event), event);\n    } else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n      const {\n        addresses,\n        includeRemoved,\n        hashesOnly\n      } = event;\n      void this._subscribe(event.tag, [AlchemySubscription.MINED_TRANSACTIONS, {\n        addresses,\n        includeRemoved,\n        hashesOnly\n      }], this.emitProcessFn(event), event);\n    } else if (event.type === 'block') {\n      void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);\n    } else if (event.type === 'filter') {\n      void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);\n    }\n  }\n  /** @internal */\n  emitProcessFn(event) {\n    switch (event.type) {\n      case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n        return result => this.emit({\n          method: AlchemySubscription.PENDING_TRANSACTIONS,\n          fromAddress: event.fromAddress,\n          toAddress: event.toAddress,\n          hashesOnly: event.hashesOnly\n        }, result);\n      case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\n        return result => this.emit({\n          method: AlchemySubscription.MINED_TRANSACTIONS,\n          addresses: event.addresses,\n          includeRemoved: event.includeRemoved,\n          hashesOnly: event.hashesOnly\n        }, result);\n      case 'block':\n        return result => {\n          const blockNumber = BigNumber.from(result.number).toNumber();\n          this._emitted.block = blockNumber;\n          this.emit('block', blockNumber);\n        };\n      case 'filter':\n        return result => {\n          if (result.removed == null) {\n            result.removed = false;\n          }\n          this.emit(event.filter, this.formatter.filterLog(result));\n        };\n      default:\n        throw new Error('Invalid event type to `emitProcessFn()`');\n    }\n  }\n  /**\r\n   * DO NOT MODIFY.\r\n   *\r\n   * Original code copied over from ether.js's `BaseProvider.off()`.\r\n   *\r\n   * This method is copied over directly in order to implement Alchemy's unique\r\n   * subscription types. The only difference is that this method calls\r\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n   * order to parse the Alchemy subscription event.\r\n   *\r\n   * @private\r\n   */\n  _off(eventName, listener) {\n    if (listener == null) {\n      return this.removeAllListeners(eventName);\n    }\n    const stopped = [];\n    let found = false;\n    const eventTag = getAlchemyEventTag(eventName);\n    this._events = this._events.filter(event => {\n      if (event.tag !== eventTag || event.listener != listener) {\n        return true;\n      }\n      if (found) {\n        return true;\n      }\n      found = true;\n      stopped.push(event);\n      return false;\n    });\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n    return this;\n  }\n  /**\r\n   * DO NOT MODIFY.\r\n   *\r\n   * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n   *\r\n   * This method is copied over directly in order to implement Alchemy's unique\r\n   * subscription types. The only difference is that this method calls\r\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n   * order to parse the Alchemy subscription event.\r\n   *\r\n   * @private\r\n   */\n  _removeAllListeners(eventName) {\n    let stopped = [];\n    if (eventName == null) {\n      stopped = this._events;\n      this._events = [];\n    } else {\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        stopped.push(event);\n        return false;\n      });\n    }\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n    return this;\n  }\n  /**\r\n   * DO NOT MODIFY.\r\n   *\r\n   * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n   *\r\n   * This method is copied over directly in order to implement Alchemy's unique\r\n   * subscription types. The only difference is that this method calls\r\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n   * order to parse the Alchemy subscription event.\r\n   *\r\n   * @private\r\n   */\n  _listenerCount(eventName) {\n    if (!eventName) {\n      return this._events.length;\n    }\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events.filter(event => {\n      return event.tag === eventTag;\n    }).length;\n  }\n  /**\r\n   * DO NOT MODIFY.\r\n   *\r\n   * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n   *\r\n   * This method is copied over directly in order to implement Alchemy's unique\r\n   * subscription types. The only difference is that this method calls\r\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n   * order to parse the Alchemy subscription event.\r\n   *\r\n   * @private\r\n   */\n  _listeners(eventName) {\n    if (eventName == null) {\n      return this._events.map(event => event.listener);\n    }\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events.filter(event => event.tag === eventTag).map(event => event.listener);\n  }\n}\nfunction getWebsocketConstructor() {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\nfunction isNodeEnvironment() {\n  return typeof process !== 'undefined' && process != null && process.versions != null && process.versions.node != null;\n}\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken() {\n  let cancelled = false;\n  return {\n    cancel: () => cancelled = true,\n    isCancelled: () => cancelled\n  };\n}\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\nfunction withBackoffRetries(f, retryCount, shouldRetry = () => true) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let nextWaitTime = 0;\n    let i = 0;\n    while (true) {\n      try {\n        return yield f();\n      } catch (error) {\n        i++;\n        if (i >= retryCount || !shouldRetry(error)) {\n          throw error;\n        }\n        yield delay(nextWaitTime);\n        if (!shouldRetry(error)) {\n          throw error;\n        }\n        nextWaitTime = nextWaitTime === 0 ? MIN_RETRY_DELAY : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n      }\n    }\n  });\n}\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction withTimeout(promise, ms) {\n  return Promise.race([promise, new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))]);\n}\nfunction getNewHeadsBlockNumber(event) {\n  return fromHex(event.number);\n}\nfunction getLogsBlockNumber(event) {\n  return fromHex(event.blockNumber);\n}\nfunction isResponse(message) {\n  return Array.isArray(message) || message.jsonrpc === '2.0' && message.id !== undefined;\n}\nfunction isSubscriptionEvent(message) {\n  return !isResponse(message);\n}\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\nfunction addToLogsEventsBuffer(pastEvents, event) {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\nexport { AlchemyWebSocketProvider };","map":{"version":3,"names":["_","__awaiter","f","fromHex","t","toHex","n","noop","C","CustomNetworks","i","isAlchemyEvent","v","verifyAlchemyEventName","c","EthersEvent","e","getAlchemyEventTag","D","DEFAULT_ALCHEMY_API_KEY","A","ALCHEMY_EVENT_TYPES","h","ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE","j","AlchemySubscription","k","ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE","V","VERSION","E","EthersNetwork","SturdyWebSocket","BigNumber","getNetwork","WebSocketProvider","AlchemyProvider","MAX_BACKFILL_BLOCKS","WebsocketBackfiller","constructor","provider","maxBackfillBlocks","getNewHeadsBackfill","isCancelled","previousHeads","fromBlockNumber","throwIfCancelled","toBlockNumber","getBlockNumber","length","getHeadEventsInRange","Math","max","lastSeenBlockNumber","number","minBlockNumber","reorgHeads","getReorgHeads","intermediateHeads","getLogsBackfill","filter","previousLogs","getLogsInRange","blockNumber","commonAncestor","getCommonAncestor","removedLogs","log","map","Object","assign","removed","fromBlockInclusive","Number","NEGATIVE_INFINITY","addedLogs","logIndex","setMaxBackfillBlock","newMax","blockNumberHex","send","toBlockExclusive","batchParts","push","method","params","blockHeads","sendBatch","toNewHeadsEvent","result","oldEvent","blockHead","getBlockByNumber","hash","reverse","oldLog","blockHash","rangeFilter","fromBlock","toBlock","head","totalDifficulty","transactions","uncles","dedupeNewHeads","events","dedupe","event","dedupeLogs","items","getKey","keysSeen","Set","forEach","item","key","has","add","CANCELLED","Error","HEARTBEAT_INTERVAL","HEARTBEAT_WAIT_TIME","BACKFILL_TIMEOUT","BACKFILL_RETRIES","RETAINED_EVENT_BLOCK_COUNT","AlchemyWebSocketProvider","config","wsConstructor","_a","apiKey","getApiKey","alchemyNetwork","getAlchemyNetwork","network","connection","getAlchemyConnectionInfo","protocol","ws","url","getWebsocketConstructor","ethersNetwork","_events","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","handleMessage","message","JSON","parse","data","isSubscriptionEvent","physicalId","subscription","virtualId","get","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","addToNewHeadsEventsBuffer","emitAndRememberEvent","getNewHeadsBlockNumber","rememberEvent","logsSubscription","logsMessage","addToLogsEventsBuffer","getLogsBlockNumber","emitEvent","handleReopen","clear","cancel","makeCancelToken","cancelBackfill","values","resubscribeAndBackfill","error","console","startHeartbeat","stopHeartbeatAndBackfill","heartbeatIntervalId","clearInterval","undefined","backfiller","addSocketListeners","on","eventName","listener","_addEventListener","once","off","_off","removeAllListeners","_removeAllListeners","listenerCount","_listenerCount","listeners","_listeners","_startEvent","customLogicTypes","includes","type","customStartEvent","_subscribe","tag","param","processFunc","subIdPromise","_subIds","startingBlockNumber","Promise","all","then","subId","resolvedParams","set","sentEvents","_subs","emit","args","stopped","eventTag","setTimeout","apply","_stopEvent","parts","nextId","payload","jsonrpc","id","sendBatchConcurrently","destroy","removeSocketListeners","isCommunityResource","_websocket","addEventListener","removeEventListener","backfillEvents","withBackoffRetries","withTimeout","emitNewHeadsEvent","emitLogsEvent","emitGenericEvent","addToPastEventsBuffer","emitFunction","emitProcessFn","setInterval","reconnect","req","fromAddress","toAddress","hashesOnly","PENDING_TRANSACTIONS","addresses","includeRemoved","MINED_TRANSACTIONS","_getFilter","from","toNumber","_emitted","block","formatter","filterLog","found","isNodeEnvironment","require","w3cwebsocket","WebSocket","process","versions","node","cancelled","MIN_RETRY_DELAY","RETRY_BACKOFF_FACTOR","MAX_RETRY_DELAY","retryCount","shouldRetry","nextWaitTime","delay","min","ms","resolve","promise","race","reject","isResponse","Array","isArray","pastEvents","currentBlockNumber","firstGoodIndex","findIndex","splice"],"sources":["F:/DDesktop/MEAN_BC/mean-stack-authentication-authorization-master/angular-15-client/node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-b8ed8f71.js"],"sourcesContent":["import { _ as __awaiter, f as fromHex, t as toHex, n as noop, C as CustomNetworks, i as isAlchemyEvent, v as verifyAlchemyEventName, c as EthersEvent, e as getAlchemyEventTag, D as DEFAULT_ALCHEMY_API_KEY, A as ALCHEMY_EVENT_TYPES, h as ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE, j as AlchemySubscription, k as ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE, V as VERSION, E as EthersNetwork } from './index-596122b1.js';\nimport SturdyWebSocket from 'sturdy-websocket';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { getNetwork } from '@ethersproject/networks';\nimport { WebSocketProvider } from '@ethersproject/providers';\nimport { AlchemyProvider } from './alchemy-provider-afa3762a.js';\nimport './api/utils';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\nimport '@ethersproject/web';\n\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */\r\nconst MAX_BACKFILL_BLOCKS = 120;\r\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */\r\nclass WebsocketBackfiller {\r\n    constructor(provider) {\r\n        this.provider = provider;\r\n        // TODO: Use HTTP provider to do backfill.\r\n        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\r\n    }\r\n    /**\r\n     * Runs backfill for `newHeads` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param previousHeads Previous head requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     * @returns A list of `newHeads` events that were sent since the last backfill.\r\n     */\r\n    getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous heads to fetch, return new heads since\r\n            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\r\n            if (previousHeads.length === 0) {\r\n                return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted event is too far back in the past, there's no need\r\n            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\r\n            // new heads.\r\n            const lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber <= minBlockNumber) {\r\n                return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // To capture all `newHeads` events, return all head events from the last\r\n            // seen block number to current + any of the previous heads that were re-orged.\r\n            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\r\n            throwIfCancelled(isCancelled);\r\n            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\r\n            throwIfCancelled(isCancelled);\r\n            return [...reorgHeads, ...intermediateHeads];\r\n        });\r\n    }\r\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */\r\n    getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous logs to fetch, return new logs since\r\n            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\r\n            if (previousLogs.length === 0) {\r\n                return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted log is too far back in the past, there's no need\r\n            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\r\n            // worth of logs.\r\n            const lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber < minBlockNumber) {\r\n                return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // Return all log events that have happened along with log events that have\r\n            // been removed due to a chain reorg.\r\n            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\r\n            throwIfCancelled(isCancelled);\r\n            // All previous logs with a block number greater than the common ancestor\r\n            // were part of a re-org, so mark them as such.\r\n            const removedLogs = previousLogs\r\n                .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\r\n                .map(log => (Object.assign(Object.assign({}, log), { removed: true })));\r\n            // If no common ancestor was found, start backfill from the oldest log's\r\n            // block number.\r\n            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\r\n                ? fromHex(previousLogs[0].blockNumber)\r\n                : commonAncestor.blockNumber;\r\n            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\r\n            // De-dupe any logs that were already emitted.\r\n            addedLogs = addedLogs.filter(log => log &&\r\n                (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\r\n                    fromHex(log.logIndex) > commonAncestor.logIndex));\r\n            throwIfCancelled(isCancelled);\r\n            return [...removedLogs, ...addedLogs];\r\n        });\r\n    }\r\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */\r\n    setMaxBackfillBlock(newMax) {\r\n        this.maxBackfillBlocks = newMax;\r\n    }\r\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockNumber() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const blockNumberHex = yield this.provider.send('eth_blockNumber');\r\n            return fromHex(blockNumberHex);\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */\r\n    getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const batchParts = [];\r\n            for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\r\n                batchParts.push({\r\n                    method: 'eth_getBlockByNumber',\r\n                    params: [toHex(i), false]\r\n                });\r\n            }\r\n            // TODO: handle errors\r\n            const blockHeads = yield this.provider.sendBatch(batchParts);\r\n            return blockHeads.map(toNewHeadsEvent);\r\n        });\r\n    }\r\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */\r\n    getReorgHeads(isCancelled, previousHeads) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const result = [];\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            for (let i = previousHeads.length - 1; i >= 0; i--) {\r\n                const oldEvent = previousHeads[i];\r\n                const blockHead = yield this.getBlockByNumber(fromHex(oldEvent.number));\r\n                throwIfCancelled(isCancelled);\r\n                // If the hashes match, then current head in the iteration was not re-orged.\r\n                if (oldEvent.hash === blockHead.hash) {\r\n                    break;\r\n                }\r\n                result.push(toNewHeadsEvent(blockHead));\r\n            }\r\n            return result.reverse();\r\n        });\r\n    }\r\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockByNumber(blockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.provider.send('eth_getBlockByNumber', [\r\n                toHex(blockNumber),\r\n                false\r\n            ]);\r\n        });\r\n    }\r\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */\r\n    getCommonAncestor(isCancelled, previousLogs) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            let blockHead = yield this.getBlockByNumber(fromHex(previousLogs[previousLogs.length - 1].blockNumber));\r\n            throwIfCancelled(isCancelled);\r\n            for (let i = previousLogs.length - 1; i >= 0; i--) {\r\n                const oldLog = previousLogs[i];\r\n                // Ensure that updated blocks are fetched every time the log's block number\r\n                // changes.\r\n                if (oldLog.blockNumber !== blockHead.number) {\r\n                    blockHead = yield this.getBlockByNumber(fromHex(oldLog.blockNumber));\r\n                }\r\n                // Since logs are ordered in ascending order, the first log that matches\r\n                // the hash should be the largest logIndex.\r\n                if (oldLog.blockHash === blockHead.hash) {\r\n                    return {\r\n                        blockNumber: fromHex(oldLog.blockNumber),\r\n                        logIndex: fromHex(oldLog.logIndex)\r\n                    };\r\n                }\r\n            }\r\n            return {\r\n                blockNumber: Number.NEGATIVE_INFINITY,\r\n                logIndex: Number.NEGATIVE_INFINITY\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const rangeFilter = Object.assign(Object.assign({}, filter), { fromBlock: toHex(fromBlockInclusive), toBlock: toHex(toBlockExclusive - 1) });\r\n            return this.provider.send('eth_getLogs', [rangeFilter]);\r\n        });\r\n    }\r\n}\r\nfunction toNewHeadsEvent(head) {\r\n    const result = Object.assign({}, head);\r\n    delete result.totalDifficulty;\r\n    delete result.transactions;\r\n    delete result.uncles;\r\n    return result;\r\n}\r\nfunction dedupeNewHeads(events) {\r\n    return dedupe(events, event => event.hash);\r\n}\r\nfunction dedupeLogs(events) {\r\n    return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\r\n}\r\nfunction dedupe(items, getKey) {\r\n    const keysSeen = new Set();\r\n    const result = [];\r\n    items.forEach(item => {\r\n        const key = getKey(item);\r\n        if (!keysSeen.has(key)) {\r\n            keysSeen.add(key);\r\n            result.push(item);\r\n        }\r\n    });\r\n    return result;\r\n}\r\nconst CANCELLED = new Error('Cancelled');\r\nfunction throwIfCancelled(isCancelled) {\r\n    if (isCancelled()) {\r\n        throw CANCELLED;\r\n    }\r\n}\n\nconst HEARTBEAT_INTERVAL = 30000;\r\nconst HEARTBEAT_WAIT_TIME = 10000;\r\nconst BACKFILL_TIMEOUT = 60000;\r\nconst BACKFILL_RETRIES = 5;\r\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\r\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\r\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyWebSocketProvider extends WebSocketProvider {\r\n    /** @internal */\r\n    constructor(config, wsConstructor) {\r\n        var _a;\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');\r\n        const protocol = `alchemy-sdk-${VERSION}`;\r\n        // Use the provided config URL override if it exists, otherwise use the created one.\r\n        const ws = new SturdyWebSocket((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\r\n            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\r\n        });\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = EthersNetwork[alchemyNetwork];\r\n        super(ws, ethersNetwork);\r\n        this._events = [];\r\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\r\n        // create new ones to replace them, but we want to create the illusion that\r\n        // the original subscriptions persist. Thus, maintain a mapping from the\r\n        // \"virtual\" subscription ids which are visible to the consumer to the\r\n        // \"physical\" subscription ids of the actual connections. This terminology is\r\n        // borrowed from virtual and physical memory, which has a similar mapping.\r\n        /** @internal */\r\n        this.virtualSubscriptionsById = new Map();\r\n        /** @internal */\r\n        this.virtualIdsByPhysicalId = new Map();\r\n        /**\r\n         * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n         * messages. To allow backfilling, track all messages that are emitted.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleMessage = (event) => {\r\n            const message = JSON.parse(event.data);\r\n            if (!isSubscriptionEvent(message)) {\r\n                return;\r\n            }\r\n            const physicalId = message.params.subscription;\r\n            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\r\n            if (!virtualId) {\r\n                return;\r\n            }\r\n            const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n            if (subscription.method !== 'eth_subscribe') {\r\n                return;\r\n            }\r\n            switch (subscription.params[0]) {\r\n                case 'newHeads': {\r\n                    const newHeadsSubscription = subscription;\r\n                    const newHeadsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = newHeadsSubscription;\r\n                    const { result } = newHeadsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToNewHeadsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    else {\r\n                        // Ethers subscription mapping will emit the event, just store it.\r\n                        this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'logs': {\r\n                    const logsSubscription = subscription;\r\n                    const logsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = logsSubscription;\r\n                    const { result } = logsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToLogsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (virtualId !== physicalId) {\r\n                        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    else {\r\n                        this.rememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        const { result } = message.params;\r\n                        this.emitEvent(virtualId, result);\r\n                    }\r\n            }\r\n        };\r\n        /**\r\n         * When the websocket connection reopens:\r\n         *\r\n         * 1. Resubscribe to all existing subscriptions and start backfilling\r\n         * 2. Restart heart beat.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleReopen = () => {\r\n            this.virtualIdsByPhysicalId.clear();\r\n            const { cancel, isCancelled } = makeCancelToken();\r\n            this.cancelBackfill = cancel;\r\n            for (const subscription of this.virtualSubscriptionsById.values()) {\r\n                void (() => __awaiter(this, void 0, void 0, function* () {\r\n                    try {\r\n                        yield this.resubscribeAndBackfill(isCancelled, subscription);\r\n                    }\r\n                    catch (error) {\r\n                        if (!isCancelled()) {\r\n                            console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\r\n                        }\r\n                    }\r\n                }))();\r\n            }\r\n            this.startHeartbeat();\r\n        };\r\n        /**\r\n         * Cancels the heartbeat and any pending backfills being performed. This is\r\n         * called when the websocket connection goes down or is disconnected.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.stopHeartbeatAndBackfill = () => {\r\n            if (this.heartbeatIntervalId != null) {\r\n                clearInterval(this.heartbeatIntervalId);\r\n                this.heartbeatIntervalId = undefined;\r\n            }\r\n            this.cancelBackfill();\r\n        };\r\n        this.apiKey = apiKey;\r\n        // Start heartbeat and backfiller for the websocket connection.\r\n        this.backfiller = new WebsocketBackfiller(this);\r\n        this.addSocketListeners();\r\n        this.startHeartbeat();\r\n        this.cancelBackfill = noop;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in CustomNetworks) {\r\n            return CustomNetworks[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return getNetwork(network);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    on(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, false);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    once(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, true);\r\n    }\r\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */\r\n    off(eventName, listener) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            return this._off(eventName, listener);\r\n        }\r\n        else {\r\n            return super.off(eventName, listener);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */\r\n    removeAllListeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._removeAllListeners(eventName);\r\n        }\r\n        else {\r\n            return super.removeAllListeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listenerCount(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listenerCount(eventName);\r\n        }\r\n        else {\r\n            return super.listenerCount(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listeners(eventName);\r\n        }\r\n        else {\r\n            return super.listeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _addEventListener(eventName, listener, once) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            verifyAlchemyEventName(eventName);\r\n            const event = new EthersEvent(getAlchemyEventTag(eventName), listener, once);\r\n            this._events.push(event);\r\n            this._startEvent(event);\r\n            return this;\r\n        }\r\n        else {\r\n            return super._addEventListener(eventName, listener, once);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */\r\n    _startEvent(event) {\r\n        // Check if the event type is a custom Alchemy subscription.\r\n        const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\r\n        if (customLogicTypes.includes(event.type)) {\r\n            this.customStartEvent(event);\r\n        }\r\n        else {\r\n            super._startEvent(event);\r\n        }\r\n    }\r\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _subscribe(tag, param, processFunc, event) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let subIdPromise = this._subIds[tag];\r\n            // BEGIN MODIFIED CODE\r\n            const startingBlockNumber = yield this.getBlockNumber();\r\n            // END MODIFIED CODE\r\n            if (subIdPromise == null) {\r\n                subIdPromise = Promise.all(param).then(param => {\r\n                    return this.send('eth_subscribe', param);\r\n                });\r\n                this._subIds[tag] = subIdPromise;\r\n            }\r\n            const subId = yield subIdPromise;\r\n            // BEGIN MODIFIED CODE\r\n            const resolvedParams = yield Promise.all(param);\r\n            this.virtualSubscriptionsById.set(subId, {\r\n                event: event,\r\n                method: 'eth_subscribe',\r\n                params: resolvedParams,\r\n                startingBlockNumber,\r\n                virtualId: subId,\r\n                physicalId: subId,\r\n                sentEvents: [],\r\n                isBackfilling: false,\r\n                backfillBuffer: []\r\n            });\r\n            this.virtualIdsByPhysicalId.set(subId, subId);\r\n            // END MODIFIED CODE\r\n            this._subs[subId] = { tag, processFunc };\r\n        });\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    emit(eventName, ...args) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            let result = false;\r\n            const stopped = [];\r\n            // This line is the only modified line from the original method.\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                setTimeout(() => {\r\n                    event.listener.apply(this, args);\r\n                }, 0);\r\n                result = true;\r\n                if (event.once) {\r\n                    stopped.push(event);\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            stopped.forEach(event => {\r\n                this._stopEvent(event);\r\n            });\r\n            return result;\r\n        }\r\n        else {\r\n            return super.emit(eventName, ...args);\r\n        }\r\n    }\r\n    /** @internal */\r\n    sendBatch(parts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let nextId = 0;\r\n            const payload = parts.map(({ method, params }) => {\r\n                return {\r\n                    method,\r\n                    params,\r\n                    jsonrpc: '2.0',\r\n                    id: `alchemy-sdk:${nextId++}`\r\n                };\r\n            });\r\n            return this.sendBatchConcurrently(payload);\r\n        });\r\n    }\r\n    /** @override */\r\n    destroy() {\r\n        this.removeSocketListeners();\r\n        this.stopHeartbeatAndBackfill();\r\n        return super.destroy();\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */\r\n    _stopEvent(event) {\r\n        let tag = event.tag;\r\n        // START MODIFIED CODE\r\n        if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\r\n            // There are remaining pending transaction listeners.\r\n            if (this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length) {\r\n                return;\r\n            }\r\n            // END MODIFIED CODE\r\n        }\r\n        else if (event.type === 'tx') {\r\n            // There are remaining transaction event listeners\r\n            if (this._events.filter(e => e.type === 'tx').length) {\r\n                return;\r\n            }\r\n            tag = 'tx';\r\n        }\r\n        else if (this.listenerCount(event.event)) {\r\n            // There are remaining event listeners\r\n            return;\r\n        }\r\n        const subId = this._subIds[tag];\r\n        if (!subId) {\r\n            return;\r\n        }\r\n        delete this._subIds[tag];\r\n        void subId.then(subId => {\r\n            if (!this._subs[subId]) {\r\n                return;\r\n            }\r\n            delete this._subs[subId];\r\n            void this.send('eth_unsubscribe', [subId]);\r\n        });\r\n    }\r\n    /** @internal */\r\n    addSocketListeners() {\r\n        this._websocket.addEventListener('message', this.handleMessage);\r\n        this._websocket.addEventListener('reopen', this.handleReopen);\r\n        this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /** @internal */\r\n    removeSocketListeners() {\r\n        this._websocket.removeEventListener('message', this.handleMessage);\r\n        this._websocket.removeEventListener('reopen', this.handleReopen);\r\n        this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */\r\n    resubscribeAndBackfill(isCancelled, subscription) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;\r\n            subscription.isBackfilling = true;\r\n            backfillBuffer.length = 0;\r\n            try {\r\n                const physicalId = yield this.send(method, params);\r\n                throwIfCancelled(isCancelled);\r\n                subscription.physicalId = physicalId;\r\n                this.virtualIdsByPhysicalId.set(physicalId, virtualId);\r\n                switch (params[0]) {\r\n                    case 'newHeads': {\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    case 'logs': {\r\n                        const filter = params[1] || {};\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitLogsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            finally {\r\n                subscription.isBackfilling = false;\r\n                backfillBuffer.length = 0;\r\n            }\r\n        });\r\n    }\r\n    /** @internal */\r\n    emitNewHeadsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitLogsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n    }\r\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */\r\n    emitAndRememberEvent(virtualId, result, getBlockNumber) {\r\n        this.rememberEvent(virtualId, result, getBlockNumber);\r\n        this.emitEvent(virtualId, result);\r\n    }\r\n    emitEvent(virtualId, result) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        this.emitGenericEvent(subscription, result);\r\n    }\r\n    /** @internal */\r\n    rememberEvent(virtualId, result, getBlockNumber) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        // Web3 modifies these event objects once we pass them on (changing hex\r\n        // numbers to numbers). We want the original event, so make a defensive\r\n        // copy.\r\n        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitGenericEvent(subscription, result) {\r\n        const emitFunction = this.emitProcessFn(subscription.event);\r\n        emitFunction(result);\r\n    }\r\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */\r\n    startHeartbeat() {\r\n        if (this.heartbeatIntervalId != null) {\r\n            return;\r\n        }\r\n        this.heartbeatIntervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                yield withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\r\n            }\r\n            catch (_a) {\r\n                this._websocket.reconnect();\r\n            }\r\n        }), HEARTBEAT_INTERVAL);\r\n    }\r\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */\r\n    // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\r\n    // TODO(errors): Use allSettled() once we have more error handling.\r\n    sendBatchConcurrently(payload) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return Promise.all(payload.map(req => this.send(req.method, req.params)));\r\n        });\r\n    }\r\n    /** @internal */\r\n    customStartEvent(event) {\r\n        if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\r\n            const { fromAddress, toAddress, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.PENDING_TRANSACTIONS,\r\n                { fromAddress, toAddress, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\r\n            const { addresses, includeRemoved, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.MINED_TRANSACTIONS,\r\n                { addresses, includeRemoved, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'block') {\r\n            void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'filter') {\r\n            void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);\r\n        }\r\n    }\r\n    /** @internal */\r\n    emitProcessFn(event) {\r\n        switch (event.type) {\r\n            case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.PENDING_TRANSACTIONS,\r\n                    fromAddress: event.fromAddress,\r\n                    toAddress: event.toAddress,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.MINED_TRANSACTIONS,\r\n                    addresses: event.addresses,\r\n                    includeRemoved: event.includeRemoved,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case 'block':\r\n                return result => {\r\n                    const blockNumber = BigNumber.from(result.number).toNumber();\r\n                    this._emitted.block = blockNumber;\r\n                    this.emit('block', blockNumber);\r\n                };\r\n            case 'filter':\r\n                return result => {\r\n                    if (result.removed == null) {\r\n                        result.removed = false;\r\n                    }\r\n                    this.emit(event.filter, this.formatter.filterLog(result));\r\n                };\r\n            default:\r\n                throw new Error('Invalid event type to `emitProcessFn()`');\r\n        }\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _off(eventName, listener) {\r\n        if (listener == null) {\r\n            return this.removeAllListeners(eventName);\r\n        }\r\n        const stopped = [];\r\n        let found = false;\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        this._events = this._events.filter(event => {\r\n            if (event.tag !== eventTag || event.listener != listener) {\r\n                return true;\r\n            }\r\n            if (found) {\r\n                return true;\r\n            }\r\n            found = true;\r\n            stopped.push(event);\r\n            return false;\r\n        });\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _removeAllListeners(eventName) {\r\n        let stopped = [];\r\n        if (eventName == null) {\r\n            stopped = this._events;\r\n            this._events = [];\r\n        }\r\n        else {\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                stopped.push(event);\r\n                return false;\r\n            });\r\n        }\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listenerCount(eventName) {\r\n        if (!eventName) {\r\n            return this._events.length;\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events.filter(event => {\r\n            return event.tag === eventTag;\r\n        }).length;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listeners(eventName) {\r\n        if (eventName == null) {\r\n            return this._events.map(event => event.listener);\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events\r\n            .filter(event => event.tag === eventTag)\r\n            .map(event => event.listener);\r\n    }\r\n}\r\nfunction getWebsocketConstructor() {\r\n    return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\r\n}\r\nfunction isNodeEnvironment() {\r\n    return (typeof process !== 'undefined' &&\r\n        process != null &&\r\n        process.versions != null &&\r\n        process.versions.node != null);\r\n}\r\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\r\nfunction makeCancelToken() {\r\n    let cancelled = false;\r\n    return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\r\n}\r\n// TODO(cleanup): replace with SDK's backoff implementation\r\nconst MIN_RETRY_DELAY = 1000;\r\nconst RETRY_BACKOFF_FACTOR = 2;\r\nconst MAX_RETRY_DELAY = 30000;\r\nfunction withBackoffRetries(f, retryCount, shouldRetry = () => true) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let nextWaitTime = 0;\r\n        let i = 0;\r\n        while (true) {\r\n            try {\r\n                return yield f();\r\n            }\r\n            catch (error) {\r\n                i++;\r\n                if (i >= retryCount || !shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                yield delay(nextWaitTime);\r\n                if (!shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                nextWaitTime =\r\n                    nextWaitTime === 0\r\n                        ? MIN_RETRY_DELAY\r\n                        : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction delay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\nfunction withTimeout(promise, ms) {\r\n    return Promise.race([\r\n        promise,\r\n        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))\r\n    ]);\r\n}\r\nfunction getNewHeadsBlockNumber(event) {\r\n    return fromHex(event.number);\r\n}\r\nfunction getLogsBlockNumber(event) {\r\n    return fromHex(event.blockNumber);\r\n}\r\nfunction isResponse(message) {\r\n    return (Array.isArray(message) ||\r\n        (message.jsonrpc === '2.0' && message.id !== undefined));\r\n}\r\nfunction isSubscriptionEvent(message) {\r\n    return !isResponse(message);\r\n}\r\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\r\n}\r\nfunction addToLogsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\r\n}\r\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */\r\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\r\n    const currentBlockNumber = getBlockNumber(event);\r\n    // Find first index of an event recent enough to retain, then drop everything\r\n    // at a lower index.\r\n    const firstGoodIndex = pastEvents.findIndex(e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\r\n    if (firstGoodIndex === -1) {\r\n        pastEvents.length = 0;\r\n    }\r\n    else {\r\n        pastEvents.splice(0, firstGoodIndex);\r\n    }\r\n    pastEvents.push(event);\r\n}\n\nexport { AlchemyWebSocketProvider };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}