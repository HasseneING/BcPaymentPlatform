{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n  detectNetwork() {\n    const _super = Object.create(null, {\n      detectNetwork: {\n        get: () => super.detectNetwork\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      let network = this.network;\n      if (network == null) {\n        network = yield _super.detectNetwork.call(this);\n        if (!network) {\n          logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n        }\n        // If still not set, set it\n        if (this._network == null) {\n          // A static network does not support \"any\"\n          defineReadOnly(this, \"_network\", network);\n          this.emit(\"network\", network, null);\n        }\n      }\n      return network;\n    });\n  }\n}\nexport class UrlJsonRpcProvider extends StaticJsonRpcProvider {\n  constructor(network, apiKey) {\n    logger.checkAbstract(new.target, UrlJsonRpcProvider);\n    // Normalize the Network and API Key\n    network = getStatic(new.target, \"getNetwork\")(network);\n    apiKey = getStatic(new.target, \"getApiKey\")(apiKey);\n    const connection = getStatic(new.target, \"getUrl\")(network, apiKey);\n    super(connection, network);\n    if (typeof apiKey === \"string\") {\n      defineReadOnly(this, \"apiKey\", apiKey);\n    } else if (apiKey != null) {\n      Object.keys(apiKey).forEach(key => {\n        defineReadOnly(this, key, apiKey[key]);\n      });\n    }\n  }\n  _startPending() {\n    logger.warn(\"WARNING: API provider does not support pending filters\");\n  }\n  isCommunityResource() {\n    return false;\n  }\n  getSigner(address) {\n    return logger.throwError(\"API provider does not support signing\", Logger.errors.UNSUPPORTED_OPERATION, {\n      operation: \"getSigner\"\n    });\n  }\n  listAccounts() {\n    return Promise.resolve([]);\n  }\n  // Return a defaultApiKey if null, otherwise validate the API key\n  static getApiKey(apiKey) {\n    return apiKey;\n  }\n  // Returns the url or connection for the given network and API key. The\n  // API key will have been sanitized by the getApiKey first, so any validation\n  // or transformations can be done there.\n  static getUrl(network, apiKey) {\n    return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n      operation: \"getUrl\"\n    });\n  }\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","defineReadOnly","getStatic","Logger","version","logger","JsonRpcProvider","StaticJsonRpcProvider","detectNetwork","_super","Object","create","get","network","call","throwError","errors","UNKNOWN_ERROR","_network","emit","UrlJsonRpcProvider","constructor","apiKey","checkAbstract","new","target","connection","keys","forEach","key","_startPending","warn","isCommunityResource","getSigner","address","UNSUPPORTED_OPERATION","operation","listAccounts","getApiKey","getUrl","NOT_IMPLEMENTED"],"sources":["F:/DDesktop/MEAN_BC/mean-stack-authentication-authorization-master/angular-15-client/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    detectNetwork() {\n        const _super = Object.create(null, {\n            detectNetwork: { get: () => super.detectNetwork }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            let network = this.network;\n            if (network == null) {\n                network = yield _super.detectNetwork.call(this);\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // If still not set, set it\n                if (this._network == null) {\n                    // A static network does not support \"any\"\n                    defineReadOnly(this, \"_network\", network);\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return network;\n        });\n    }\n}\nexport class UrlJsonRpcProvider extends StaticJsonRpcProvider {\n    constructor(network, apiKey) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n        // Normalize the Network and API Key\n        network = getStatic(new.target, \"getNetwork\")(network);\n        apiKey = getStatic(new.target, \"getApiKey\")(apiKey);\n        const connection = getStatic(new.target, \"getUrl\")(network, apiKey);\n        super(connection, network);\n        if (typeof (apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        }\n        else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly(this, key, apiKey[key]);\n            });\n        }\n    }\n    _startPending() {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n    isCommunityResource() {\n        return false;\n    }\n    getSigner(address) {\n        return logger.throwError(\"API provider does not support signing\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"getSigner\" });\n    }\n    listAccounts() {\n        return Promise.resolve([]);\n    }\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey) {\n        return apiKey;\n    }\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network, apiKey) {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,SAAS,GAAI,IAAI,IAAI,IAAI,CAACA,SAAS,IAAK,UAAUC,OAAO,EAAEC,UAAU,EAAEC,CAAC,EAAEC,SAAS,EAAE;EACrF,SAASC,KAAK,CAACC,KAAK,EAAE;IAAE,OAAOA,KAAK,YAAYH,CAAC,GAAGG,KAAK,GAAG,IAAIH,CAAC,CAAC,UAAUI,OAAO,EAAE;MAAEA,OAAO,CAACD,KAAK,CAAC;IAAE,CAAC,CAAC;EAAE;EAC3G,OAAO,KAAKH,CAAC,KAAKA,CAAC,GAAGK,OAAO,CAAC,EAAE,UAAUD,OAAO,EAAEE,MAAM,EAAE;IACvD,SAASC,SAAS,CAACJ,KAAK,EAAE;MAAE,IAAI;QAAEK,IAAI,CAACP,SAAS,CAACQ,IAAI,CAACN,KAAK,CAAC,CAAC;MAAE,CAAC,CAAC,OAAOO,CAAC,EAAE;QAAEJ,MAAM,CAACI,CAAC,CAAC;MAAE;IAAE;IAC1F,SAASC,QAAQ,CAACR,KAAK,EAAE;MAAE,IAAI;QAAEK,IAAI,CAACP,SAAS,CAAC,OAAO,CAAC,CAACE,KAAK,CAAC,CAAC;MAAE,CAAC,CAAC,OAAOO,CAAC,EAAE;QAAEJ,MAAM,CAACI,CAAC,CAAC;MAAE;IAAE;IAC7F,SAASF,IAAI,CAACI,MAAM,EAAE;MAAEA,MAAM,CAACC,IAAI,GAAGT,OAAO,CAACQ,MAAM,CAACT,KAAK,CAAC,GAAGD,KAAK,CAACU,MAAM,CAACT,KAAK,CAAC,CAACW,IAAI,CAACP,SAAS,EAAEI,QAAQ,CAAC;IAAE;IAC7GH,IAAI,CAAC,CAACP,SAAS,GAAGA,SAAS,CAACc,KAAK,CAACjB,OAAO,EAAEC,UAAU,IAAI,EAAE,CAAC,EAAEU,IAAI,EAAE,CAAC;EACzE,CAAC,CAAC;AACN,CAAC;AACD,SAASO,cAAc,EAAEC,SAAS,QAAQ,2BAA2B;AACrE,SAASC,MAAM,QAAQ,uBAAuB;AAC9C,SAASC,OAAO,QAAQ,YAAY;AACpC,MAAMC,MAAM,GAAG,IAAIF,MAAM,CAACC,OAAO,CAAC;AAClC,SAASE,eAAe,QAAQ,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,qBAAqB,SAASD,eAAe,CAAC;EACvDE,aAAa,GAAG;IACZ,MAAMC,MAAM,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,EAAE;MAC/BH,aAAa,EAAE;QAAEI,GAAG,EAAE,MAAM,KAAK,CAACJ;MAAc;IACpD,CAAC,CAAC;IACF,OAAO1B,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;MAChD,IAAI+B,OAAO,GAAG,IAAI,CAACA,OAAO;MAC1B,IAAIA,OAAO,IAAI,IAAI,EAAE;QACjBA,OAAO,GAAG,MAAMJ,MAAM,CAACD,aAAa,CAACM,IAAI,CAAC,IAAI,CAAC;QAC/C,IAAI,CAACD,OAAO,EAAE;UACVR,MAAM,CAACU,UAAU,CAAC,qBAAqB,EAAEZ,MAAM,CAACa,MAAM,CAACC,aAAa,EAAE,CAAC,CAAC,CAAC;QAC7E;QACA;QACA,IAAI,IAAI,CAACC,QAAQ,IAAI,IAAI,EAAE;UACvB;UACAjB,cAAc,CAAC,IAAI,EAAE,UAAU,EAAEY,OAAO,CAAC;UACzC,IAAI,CAACM,IAAI,CAAC,SAAS,EAAEN,OAAO,EAAE,IAAI,CAAC;QACvC;MACJ;MACA,OAAOA,OAAO;IAClB,CAAC,CAAC;EACN;AACJ;AACA,OAAO,MAAMO,kBAAkB,SAASb,qBAAqB,CAAC;EAC1Dc,WAAW,CAACR,OAAO,EAAES,MAAM,EAAE;IACzBjB,MAAM,CAACkB,aAAa,CAACC,GAAG,CAACC,MAAM,EAAEL,kBAAkB,CAAC;IACpD;IACAP,OAAO,GAAGX,SAAS,CAACsB,GAAG,CAACC,MAAM,EAAE,YAAY,CAAC,CAACZ,OAAO,CAAC;IACtDS,MAAM,GAAGpB,SAAS,CAACsB,GAAG,CAACC,MAAM,EAAE,WAAW,CAAC,CAACH,MAAM,CAAC;IACnD,MAAMI,UAAU,GAAGxB,SAAS,CAACsB,GAAG,CAACC,MAAM,EAAE,QAAQ,CAAC,CAACZ,OAAO,EAAES,MAAM,CAAC;IACnE,KAAK,CAACI,UAAU,EAAEb,OAAO,CAAC;IAC1B,IAAI,OAAQS,MAAO,KAAK,QAAQ,EAAE;MAC9BrB,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAEqB,MAAM,CAAC;IAC1C,CAAC,MACI,IAAIA,MAAM,IAAI,IAAI,EAAE;MACrBZ,MAAM,CAACiB,IAAI,CAACL,MAAM,CAAC,CAACM,OAAO,CAAEC,GAAG,IAAK;QACjC5B,cAAc,CAAC,IAAI,EAAE4B,GAAG,EAAEP,MAAM,CAACO,GAAG,CAAC,CAAC;MAC1C,CAAC,CAAC;IACN;EACJ;EACAC,aAAa,GAAG;IACZzB,MAAM,CAAC0B,IAAI,CAAC,wDAAwD,CAAC;EACzE;EACAC,mBAAmB,GAAG;IAClB,OAAO,KAAK;EAChB;EACAC,SAAS,CAACC,OAAO,EAAE;IACf,OAAO7B,MAAM,CAACU,UAAU,CAAC,uCAAuC,EAAEZ,MAAM,CAACa,MAAM,CAACmB,qBAAqB,EAAE;MAAEC,SAAS,EAAE;IAAY,CAAC,CAAC;EACtI;EACAC,YAAY,GAAG;IACX,OAAO/C,OAAO,CAACD,OAAO,CAAC,EAAE,CAAC;EAC9B;EACA;EACA,OAAOiD,SAAS,CAAChB,MAAM,EAAE;IACrB,OAAOA,MAAM;EACjB;EACA;EACA;EACA;EACA,OAAOiB,MAAM,CAAC1B,OAAO,EAAES,MAAM,EAAE;IAC3B,OAAOjB,MAAM,CAACU,UAAU,CAAC,mDAAmD,EAAEZ,MAAM,CAACa,MAAM,CAACwB,eAAe,EAAE;MACzGJ,SAAS,EAAE;IACf,CAAC,CAAC;EACN;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}