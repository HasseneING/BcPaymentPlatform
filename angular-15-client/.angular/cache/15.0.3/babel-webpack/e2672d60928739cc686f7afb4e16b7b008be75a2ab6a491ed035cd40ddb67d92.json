{"ast":null,"code":"\"use strict\";\n\nimport { arrayify, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BigNumber, isBigNumberish } from \"./bignumber\";\nconst _constructorGuard = {};\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\nfunction throwFault(message, fault, operation, value) {\n  const params = {\n    fault: fault,\n    operation: operation\n  };\n  if (value !== undefined) {\n    params.value = value;\n  }\n  return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) {\n  zeros += zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals) {\n  if (typeof decimals !== \"number\") {\n    try {\n      decimals = BigNumber.from(decimals).toNumber();\n    } catch (e) {}\n  }\n  if (typeof decimals === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n    return \"1\" + zeros.substring(0, decimals);\n  }\n  return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\nexport function formatFixed(value, decimals) {\n  if (decimals == null) {\n    decimals = 0;\n  }\n  const multiplier = getMultiplier(decimals);\n  // Make sure wei is a big number (convert as necessary)\n  value = BigNumber.from(value);\n  const negative = value.lt(Zero);\n  if (negative) {\n    value = value.mul(NegativeOne);\n  }\n  let fraction = value.mod(multiplier).toString();\n  while (fraction.length < multiplier.length - 1) {\n    fraction = \"0\" + fraction;\n  }\n  // Strip training 0\n  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n  const whole = value.div(multiplier).toString();\n  if (multiplier.length === 1) {\n    value = whole;\n  } else {\n    value = whole + \".\" + fraction;\n  }\n  if (negative) {\n    value = \"-\" + value;\n  }\n  return value;\n}\nexport function parseFixed(value, decimals) {\n  if (decimals == null) {\n    decimals = 0;\n  }\n  const multiplier = getMultiplier(decimals);\n  if (typeof value !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n    logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n  }\n  // Is it negative?\n  const negative = value.substring(0, 1) === \"-\";\n  if (negative) {\n    value = value.substring(1);\n  }\n  if (value === \".\") {\n    logger.throwArgumentError(\"missing value\", \"value\", value);\n  }\n  // Split it into a whole and fractional part\n  const comps = value.split(\".\");\n  if (comps.length > 2) {\n    logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n  }\n  let whole = comps[0],\n    fraction = comps[1];\n  if (!whole) {\n    whole = \"0\";\n  }\n  if (!fraction) {\n    fraction = \"0\";\n  }\n  // Trim trailing zeros\n  while (fraction[fraction.length - 1] === \"0\") {\n    fraction = fraction.substring(0, fraction.length - 1);\n  }\n  // Check the fraction doesn't exceed our decimals size\n  if (fraction.length > multiplier.length - 1) {\n    throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n  }\n  // If decimals is 0, we have an empty string for fraction\n  if (fraction === \"\") {\n    fraction = \"0\";\n  }\n  // Fully pad the string with zeros to get to wei\n  while (fraction.length < multiplier.length - 1) {\n    fraction += \"0\";\n  }\n  const wholeValue = BigNumber.from(whole);\n  const fractionValue = BigNumber.from(fraction);\n  let wei = wholeValue.mul(multiplier).add(fractionValue);\n  if (negative) {\n    wei = wei.mul(NegativeOne);\n  }\n  return wei;\n}\nexport class FixedFormat {\n  constructor(constructorGuard, signed, width, decimals) {\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new FixedFormat\"\n      });\n    }\n    this.signed = signed;\n    this.width = width;\n    this.decimals = decimals;\n    this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    this._multiplier = getMultiplier(decimals);\n    Object.freeze(this);\n  }\n  static from(value) {\n    if (value instanceof FixedFormat) {\n      return value;\n    }\n    if (typeof value === \"number\") {\n      value = `fixed128x${value}`;\n    }\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n    if (typeof value === \"string\") {\n      if (value === \"fixed\") {\n        // defaults...\n      } else if (value === \"ufixed\") {\n        signed = false;\n      } else {\n        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n        if (!match) {\n          logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n        }\n        signed = match[1] !== \"u\";\n        width = parseInt(match[2]);\n        decimals = parseInt(match[3]);\n      }\n    } else if (value) {\n      const check = (key, type, defaultValue) => {\n        if (value[key] == null) {\n          return defaultValue;\n        }\n        if (typeof value[key] !== type) {\n          logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n        }\n        return value[key];\n      };\n      signed = check(\"signed\", \"boolean\", signed);\n      width = check(\"width\", \"number\", width);\n      decimals = check(\"decimals\", \"number\", decimals);\n    }\n    if (width % 8) {\n      logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n    }\n    if (decimals > 80) {\n      logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n    }\n    return new FixedFormat(_constructorGuard, signed, width, decimals);\n  }\n}\nexport class FixedNumber {\n  constructor(constructorGuard, hex, value, format) {\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new FixedFormat\"\n      });\n    }\n    this.format = format;\n    this._hex = hex;\n    this._value = value;\n    this._isFixedNumber = true;\n    Object.freeze(this);\n  }\n  _checkFormat(other) {\n    if (this.format.name !== other.format.name) {\n      logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n  }\n  addUnsafe(other) {\n    this._checkFormat(other);\n    const a = parseFixed(this._value, this.format.decimals);\n    const b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n  }\n  subUnsafe(other) {\n    this._checkFormat(other);\n    const a = parseFixed(this._value, this.format.decimals);\n    const b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n  }\n  mulUnsafe(other) {\n    this._checkFormat(other);\n    const a = parseFixed(this._value, this.format.decimals);\n    const b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n  }\n  divUnsafe(other) {\n    this._checkFormat(other);\n    const a = parseFixed(this._value, this.format.decimals);\n    const b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n  }\n  floor() {\n    const comps = this.toString().split(\".\");\n    if (comps.length === 1) {\n      comps.push(\"0\");\n    }\n    let result = FixedNumber.from(comps[0], this.format);\n    const hasFraction = !comps[1].match(/^(0*)$/);\n    if (this.isNegative() && hasFraction) {\n      result = result.subUnsafe(ONE.toFormat(result.format));\n    }\n    return result;\n  }\n  ceiling() {\n    const comps = this.toString().split(\".\");\n    if (comps.length === 1) {\n      comps.push(\"0\");\n    }\n    let result = FixedNumber.from(comps[0], this.format);\n    const hasFraction = !comps[1].match(/^(0*)$/);\n    if (!this.isNegative() && hasFraction) {\n      result = result.addUnsafe(ONE.toFormat(result.format));\n    }\n    return result;\n  }\n  // @TODO: Support other rounding algorithms\n  round(decimals) {\n    if (decimals == null) {\n      decimals = 0;\n    }\n    // If we are already in range, we're done\n    const comps = this.toString().split(\".\");\n    if (comps.length === 1) {\n      comps.push(\"0\");\n    }\n    if (decimals < 0 || decimals > 80 || decimals % 1) {\n      logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n    }\n    if (comps[1].length <= decimals) {\n      return this;\n    }\n    const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n    const bump = BUMP.toFormat(this.format);\n    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n  }\n  isZero() {\n    return this._value === \"0.0\" || this._value === \"0\";\n  }\n  isNegative() {\n    return this._value[0] === \"-\";\n  }\n  toString() {\n    return this._value;\n  }\n  toHexString(width) {\n    if (width == null) {\n      return this._hex;\n    }\n    if (width % 8) {\n      logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n    }\n    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n    return hexZeroPad(hex, width / 8);\n  }\n  toUnsafeFloat() {\n    return parseFloat(this.toString());\n  }\n  toFormat(format) {\n    return FixedNumber.fromString(this._value, format);\n  }\n  static fromValue(value, decimals, format) {\n    // If decimals looks more like a format, and there is no format, shift the parameters\n    if (format == null && decimals != null && !isBigNumberish(decimals)) {\n      format = decimals;\n      decimals = null;\n    }\n    if (decimals == null) {\n      decimals = 0;\n    }\n    if (format == null) {\n      format = \"fixed\";\n    }\n    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n  }\n  static fromString(value, format) {\n    if (format == null) {\n      format = \"fixed\";\n    }\n    const fixedFormat = FixedFormat.from(format);\n    const numeric = parseFixed(value, fixedFormat.decimals);\n    if (!fixedFormat.signed && numeric.lt(Zero)) {\n      throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n    }\n    let hex = null;\n    if (fixedFormat.signed) {\n      hex = numeric.toTwos(fixedFormat.width).toHexString();\n    } else {\n      hex = numeric.toHexString();\n      hex = hexZeroPad(hex, fixedFormat.width / 8);\n    }\n    const decimal = formatFixed(numeric, fixedFormat.decimals);\n    return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n  }\n  static fromBytes(value, format) {\n    if (format == null) {\n      format = \"fixed\";\n    }\n    const fixedFormat = FixedFormat.from(format);\n    if (arrayify(value).length > fixedFormat.width / 8) {\n      throw new Error(\"overflow\");\n    }\n    let numeric = BigNumber.from(value);\n    if (fixedFormat.signed) {\n      numeric = numeric.fromTwos(fixedFormat.width);\n    }\n    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n    const decimal = formatFixed(numeric, fixedFormat.decimals);\n    return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n  }\n  static from(value, format) {\n    if (typeof value === \"string\") {\n      return FixedNumber.fromString(value, format);\n    }\n    if (isBytes(value)) {\n      return FixedNumber.fromBytes(value, format);\n    }\n    try {\n      return FixedNumber.fromValue(value, 0, format);\n    } catch (error) {\n      // Allow NUMERIC_FAULT to bubble up\n      if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n        throw error;\n      }\n    }\n    return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n  }\n  static isFixedNumber(value) {\n    return !!(value && value._isFixedNumber);\n  }\n}\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");","map":{"version":3,"names":["arrayify","hexZeroPad","isBytes","Logger","version","logger","BigNumber","isBigNumberish","_constructorGuard","Zero","from","NegativeOne","throwFault","message","fault","operation","value","params","undefined","throwError","errors","NUMERIC_FAULT","zeros","length","getMultiplier","decimals","toNumber","e","substring","throwArgumentError","formatFixed","multiplier","negative","lt","mul","fraction","mod","toString","match","whole","div","parseFixed","comps","split","wholeValue","fractionValue","wei","add","FixedFormat","constructor","constructorGuard","signed","width","UNSUPPORTED_OPERATION","name","String","_multiplier","Object","freeze","parseInt","check","key","type","defaultValue","FixedNumber","hex","format","_hex","_value","_isFixedNumber","_checkFormat","other","addUnsafe","a","b","fromValue","subUnsafe","sub","mulUnsafe","divUnsafe","floor","push","result","hasFraction","isNegative","ONE","toFormat","ceiling","round","factor","bump","BUMP","isZero","toHexString","fromTwos","toTwos","toUnsafeFloat","parseFloat","fromString","fixedFormat","numeric","decimal","fromBytes","Error","error","code","INVALID_ARGUMENT","isFixedNumber"],"sources":["F:/DDesktop/MEAN_BC/mean-stack-authentication-authorization-master/angular-15-client/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js"],"sourcesContent":["\"use strict\";\nimport { arrayify, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BigNumber, isBigNumberish } from \"./bignumber\";\nconst _constructorGuard = {};\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\nfunction throwFault(message, fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value !== undefined) {\n        params.value = value;\n    }\n    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) {\n    zeros += zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals) {\n    if (typeof (decimals) !== \"number\") {\n        try {\n            decimals = BigNumber.from(decimals).toNumber();\n        }\n        catch (e) { }\n    }\n    if (typeof (decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\nexport function formatFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    // Make sure wei is a big number (convert as necessary)\n    value = BigNumber.from(value);\n    const negative = value.lt(Zero);\n    if (negative) {\n        value = value.mul(NegativeOne);\n    }\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) {\n        fraction = \"0\" + fraction;\n    }\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    }\n    else {\n        value = whole + \".\" + fraction;\n    }\n    if (negative) {\n        value = \"-\" + value;\n    }\n    return value;\n}\nexport function parseFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    if (typeof (value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) {\n        value = value.substring(1);\n    }\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) {\n        whole = \"0\";\n    }\n    if (!fraction) {\n        fraction = \"0\";\n    }\n    // Trim trailing zeros\n    while (fraction[fraction.length - 1] === \"0\") {\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") {\n        fraction = \"0\";\n    }\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) {\n        fraction += \"0\";\n    }\n    const wholeValue = BigNumber.from(whole);\n    const fractionValue = BigNumber.from(fraction);\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n    if (negative) {\n        wei = wei.mul(NegativeOne);\n    }\n    return wei;\n}\nexport class FixedFormat {\n    constructor(constructorGuard, signed, width, decimals) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n        this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n        this._multiplier = getMultiplier(decimals);\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (value instanceof FixedFormat) {\n            return value;\n        }\n        if (typeof (value) === \"number\") {\n            value = `fixed128x${value}`;\n        }\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n        if (typeof (value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            }\n            else if (value === \"ufixed\") {\n                signed = false;\n            }\n            else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) {\n                    logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n                }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        }\n        else if (value) {\n            const check = (key, type, defaultValue) => {\n                if (value[key] == null) {\n                    return defaultValue;\n                }\n                if (typeof (value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            };\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\nexport class FixedNumber {\n    constructor(constructorGuard, hex, value, format) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n        this._isFixedNumber = true;\n        Object.freeze(this);\n    }\n    _checkFormat(other) {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n    addUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n    subUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n    mulUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n    divUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n    floor() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    ceiling() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    // @TODO: Support other rounding algorithms\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n        if (comps[1].length <= decimals) {\n            return this;\n        }\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n    isZero() {\n        return (this._value === \"0.0\" || this._value === \"0\");\n    }\n    isNegative() {\n        return (this._value[0] === \"-\");\n    }\n    toString() { return this._value; }\n    toHexString(width) {\n        if (width == null) {\n            return this._hex;\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n        }\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return hexZeroPad(hex, width / 8);\n    }\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    toFormat(format) {\n        return FixedNumber.fromString(this._value, format);\n    }\n    static fromValue(value, decimals, format) {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n        if (decimals == null) {\n            decimals = 0;\n        }\n        if (format == null) {\n            format = \"fixed\";\n        }\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n    static fromString(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        const numeric = parseFixed(value, fixedFormat.decimals);\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n        let hex = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        }\n        else {\n            hex = numeric.toHexString();\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\n        }\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static fromBytes(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        if (arrayify(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n        let numeric = BigNumber.from(value);\n        if (fixedFormat.signed) {\n            numeric = numeric.fromTwos(fixedFormat.width);\n        }\n        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static from(value, format) {\n        if (typeof (value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n        if (isBytes(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        }\n        catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n    static isFixedNumber(value) {\n        return !!(value && value._isFixedNumber);\n    }\n}\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}